{
  ".gitignore": "# Sorties & mÃ©dias\ndownloads/\nVideos/\nAudios/\n*.mp4\n*.mkv\n*.webm\n*.mp3\n*.m4a\n\n# Python cache\n__pycache__/\n*.pyc\n\n# Secrets & config locale\n.env\nflowgrab_config.json\n",
  "README.md": "# Projet-buisness\r\n",
  "flowgrab_tabs.py": "import os, subprocess, shutil, sys, pathlib, mimetypes\nimport signal\nimport tempfile\nimport threading\nimport asyncio\nimport secrets\nimport re\nimport time\nimport random\n\nOUT_DIR = pathlib.Path(r\"C:\\Users\\Lamine\\Desktop\\Projet final\\Application\\downloads\")\nOUT_DIR.mkdir(parents=True, exist_ok=True)\nVIDEOS_DIR = OUT_DIR / \"Videos\"\nAUDIOS_DIR = OUT_DIR / \"Audios\"\nTRANSCRIPTION_DIR = OUT_DIR / \"Transcription\"\nVIDEOS_DIR.mkdir(parents=True, exist_ok=True)\nAUDIOS_DIR.mkdir(parents=True, exist_ok=True)\nTRANSCRIPTION_DIR.mkdir(parents=True, exist_ok=True)\nDOWNLOAD_ARCHIVE = OUT_DIR / \"archive.txt\"\nDOWNLOAD_ARCHIVE_TT = OUT_DIR / \"archive_tiktok.txt\"\n\nfrom typing import Optional, List, Dict, Any, TYPE_CHECKING, Callable, Tuple\n\nif TYPE_CHECKING:  # pragma: no cover - typing uniquement\n    from telegram.ext import Application\n\nimport telegram as tg  # pour la version\n\nYOUTUBE_REGEX = re.compile(\n    r\"(https?://(?:www\\.)?(?:youtube\\.com/watch\\?\\S*?v=[^\\s&]+|youtu\\.be/[^\\s/?#]+)[^\\s]*)\",\n    re.IGNORECASE,\n)\n\nTIKTOK_REGEX = re.compile(\n    r\"(https?://(?:www\\.)?(?:tiktok\\.com/.+?/video/\\d+|vt\\.tiktok\\.com/\\S+|vm\\.tiktok\\.com/\\S+))\",\n    re.IGNORECASE,\n)\n\nBROWSER_TRY_ORDER = (\"edge\", \"chrome\", \"brave\", \"vivaldi\", \"opera\", \"chromium\", \"firefox\")\n\n\nclass YtdlpLogger:\n    def __init__(self, emit: Callable[[str], None]):\n        self.emit = emit\n\n    def debug(self, msg: str) -> None:  # pragma: no cover - silencieux par dÃ©faut\n        # ignorer le bruit debug de yt-dlp pour garder la console propre\n        return\n\n    def warning(self, msg: str) -> None:\n        try:\n            self.emit(f\"[yt-dlp] {msg}\")\n        except Exception:\n            pass\n\n    def error(self, msg: str) -> None:\n        try:\n            self.emit(f\"[yt-dlp] {msg}\")\n        except Exception:\n            pass\n\n\ndef _apply_cookies_to_opts(opts: dict, cfg: dict) -> None:\n    \"\"\"PrÃ©pare les options yt-dlp selon la config courante.\"\"\"\n\n    mode = (cfg.get(\"browser_cookies\") or \"auto\").strip().lower()\n    cookies = (cfg.get(\"cookies_path\") or \"\").strip()\n\n    opts.pop(\"cookiefile\", None)\n    opts.pop(\"cookiesfrombrowser\", None)\n\n    if mode == \"none\":\n        return\n\n    if mode == \"cookiefile\":\n        if cookies:\n            opts[\"cookiefile\"] = cookies\n        return\n\n    if mode in BROWSER_TRY_ORDER:\n        opts[\"cookiesfrombrowser\"] = (mode, None, None, None)\n        return\n\n    # mode auto : utiliser le premier navigateur de la liste, le reste sera gÃ©rÃ© via fallback\n    order = _browser_fallback_order(cfg)\n    browser = order[0] if order else BROWSER_TRY_ORDER[0]\n    opts[\"cookiesfrombrowser\"] = (browser, None, None, None)\n\n\ndef _is_dpapi_error(exc: Exception) -> bool:\n    msg = (str(exc) or \"\").lower()\n    needles = (\"dpapi\", \"decrypt\", \"encrypted_key\", \"os_crypt\", \"failed to decrypt\")\n    return any(k in msg for k in needles)\n\n\ndef _is_chrome_copy_error(exc: Exception) -> bool:\n    msg = (str(exc) or \"\").lower()\n    if not msg:\n        return False\n    return (\"could not copy\" in msg and \"cookie\" in msg and \"database\" in msg) or (\n        \"could not copy chrome cookie database\" in msg\n    )\n\n\ndef _browser_fallback_order(cfg: dict) -> list[str]:\n    pref = (cfg.get(\"browser_cookies\") or \"auto\").strip().lower()\n    if pref in BROWSER_TRY_ORDER:\n        return [pref]\n    if pref == \"auto\":\n        return list(BROWSER_TRY_ORDER)\n    return []\n\n\ndef _ptb_major_minor() -> tuple[int, int]:\n    try:\n        parts = tg.__version__.split(\".\")[:2]\n        return int(parts[0]), int(parts[1])\n    except Exception:\n        return 20, 0\n\n\ndef _backoff_sleep(attempt: int, base: float = 1.5, jitter: bool = True) -> None:\n    delay = base ** attempt\n    if jitter:\n        delay += random.uniform(0, 0.5)\n    time.sleep(delay)\n\n\ndef normalize_yt(u: str) -> str:\n    \"\"\"\n    Normalise une URL YouTube :\n    - supprime le paramÃ¨tre ?si=... (inutile pour yt-dlp)\n    - convertit youtu.be/<id> en https://www.youtube.com/watch?v=<id>\n    \"\"\"\n    try:\n        if not u:\n            return u\n        # retire ?si=... ou &si=...\n        u = re.sub(r'([?&])si=[^&]+&?', r'\\1', u)\n        u = re.sub(r'[?&]$', '', u)\n\n        m = re.search(r'youtu\\.be/([A-Za-z0-9_-]{6,})', u)\n        if m:\n            vid = m.group(1)\n            return f\"https://www.youtube.com/watch?v={vid}\"\n        return u\n    except Exception:\n        return u\n\n\ndef normalize_tiktok(u: str) -> str:\n    \"\"\"\n    Normalise une URL TikTok :\n    - supprime certains paramÃ¨tres marketing courants\n    - laisse les liens courts (vm./vt.) tels quels (yt-dlp gÃ¨re la redirection)\n    \"\"\"\n    try:\n        if not u:\n            return u\n        # retire paramÃ¨tres bruyants (_r, _t, share_link_id, etc.)\n        u = re.sub(r'([?&])(?:_r|_t|share_link_id|sender_device)=\\w+&?', r'\\1', u)\n        u = re.sub(r'[?&]$', '', u)\n        return u\n    except Exception:\n        return u\n\n\ndef normalize_url(u: str) -> str:\n    if not u:\n        return u\n    low = u.lower()\n    if \"youtu\" in low:\n        return normalize_yt(u)\n    if \"tiktok.com\" in low or \"vm.tiktok.com\" in low or \"vt.tiktok.com\" in low:\n        return normalize_tiktok(u)\n    return u\n\n\ndef _is_path_in_dir(candidate: pathlib.Path, directory: pathlib.Path) -> bool:\n    try:\n        candidate.relative_to(directory)\n        return True\n    except ValueError:\n        return False\n\n\ndef extract_basic_info(url: str) -> dict:\n    \"\"\"RÃ©cupÃ¨re les mÃ©tadonnÃ©es d'une vidÃ©o sans lancer de tÃ©lÃ©chargement.\"\"\"\n    u = normalize_url(url)\n    cfg = load_config()\n    user_agent = (cfg.get(\"user_agent\") or DEFAULT_CONFIG[\"user_agent\"]).strip()\n    base_opts: dict[str, Any] = {\n        \"quiet\": True,\n        \"no_warnings\": True,\n        \"retries\": 2,\n        \"socket_timeout\": 15,\n        \"logger\": YtdlpLogger(lambda _: None),\n    }\n    if user_agent:\n        base_opts[\"http_headers\"] = {\"User-Agent\": user_agent}\n\n    cookies_path = (cfg.get(\"cookies_path\") or \"\").strip()\n    browser_pref = (cfg.get(\"browser_cookies\") or \"auto\").strip().lower()\n\n    def _extract(local_opts: dict[str, Any]) -> dict:\n        last_exc: Exception | None = None\n        for attempt in range(3):\n            try:\n                with YoutubeDL(local_opts) as ydl:\n                    info = ydl.extract_info(u, download=False)\n                if info and info.get(\"entries\"):\n                    info = info[\"entries\"][0]\n                return info or {}\n            except Exception as exc:  # pragma: no cover - dÃ©pend du rÃ©seau\n                last_exc = exc\n                msg = (str(exc) or \"\").lower()\n                if \"429\" in msg or \"too many requests\" in msg:\n                    _backoff_sleep(attempt)\n                    continue\n                raise\n        if last_exc:\n            raise last_exc\n        return {}\n\n    if browser_pref == \"cookiefile\" and cookies_path:\n        legacy_opts = dict(base_opts)\n        legacy_opts[\"cookiefile\"] = cookies_path\n        legacy_opts.pop(\"cookiesfrombrowser\", None)\n        try:\n            return _extract(legacy_opts)\n        except Exception:\n            # On tentera sans cookies juste aprÃ¨s\n            pass\n\n    if browser_pref == \"none\":\n        opts_no_cookies = dict(base_opts)\n        opts_no_cookies.pop(\"cookiefile\", None)\n        opts_no_cookies.pop(\"cookiesfrombrowser\", None)\n        return _extract(opts_no_cookies)\n\n    last_error: Exception | None = None\n\n    browsers = _browser_fallback_order(cfg)\n    explicit_browser = browser_pref in BROWSER_TRY_ORDER\n    for browser in browsers:\n        local_opts = dict(base_opts)\n        local_opts[\"cookiesfrombrowser\"] = (browser, None, None, None)\n        try:\n            return _extract(local_opts)\n        except Exception as exc:\n            last_error = exc\n            msg = (str(exc) or \"\").lower()\n            if browser == \"firefox\" and (\"pycryptodomex\" in msg or \"cryptodome\" in msg):\n                if explicit_browser:\n                    raise RuntimeError(\n                        \"Lecture des cookies Firefox impossible : installez 'pycryptodomex' (pip install pycryptodomex).\"\n                    )\n                continue\n            if _is_dpapi_error(exc) or _is_chrome_copy_error(exc):\n                continue\n            raise\n\n    if browser_pref == \"auto\" and cookies_path:\n        legacy_opts = dict(base_opts)\n        legacy_opts[\"cookiefile\"] = cookies_path\n        legacy_opts.pop(\"cookiesfrombrowser\", None)\n        try:\n            return _extract(legacy_opts)\n        except Exception as exc:\n            last_error = exc\n\n    # Dernier recours : sans cookies\n    opts_no_cookies = dict(base_opts)\n    opts_no_cookies.pop(\"cookiefile\", None)\n    opts_no_cookies.pop(\"cookiesfrombrowser\", None)\n    try:\n        return _extract(opts_no_cookies)\n    except Exception as exc:\n        # Retourner l'erreur de la derniÃ¨re tentative si ce n'est pas un problÃ¨me de cookies\n        if not (_is_dpapi_error(exc) or _is_chrome_copy_error(exc)):\n            raise\n        if last_error and not (_is_dpapi_error(last_error) or _is_chrome_copy_error(last_error)):\n            raise last_error\n        raise RuntimeError(\n            \"Impossible de rÃ©cupÃ©rer les informations vidÃ©o : les cookies navigateur sont indisponibles et la requÃªte sans cookies a Ã©chouÃ©.\"\n        )\n\n    # Si aucune erreur n'a Ã©tÃ© levÃ©e, retourner un dict vide (pas censÃ© arriver)\n    return {}\n\n# PATCH START: config persistante\nCONFIG_PATH = OUT_DIR / \"flowgrab_config.json\"\n\nDEFAULT_CONFIG = {\n    \"webhook_path\": \"/webhook/Audio\",\n    \"webhook_base\": \"\",\n    \"webhook_full\": \"\",\n    \"last_updated\": \"\",\n    \"telegram_token\": \"\",\n    \"telegram_mode\": \"polling\",\n    \"telegram_port\": 8081,\n    \"cookies_path\": \"\",\n    \"user_agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n    \"browser_cookies\": \"auto\",  # \"auto\" | navigateurs | \"cookiefile\" | \"none\"\n}\n\n\ndef _ensure_config_defaults(data: Optional[dict]) -> dict:\n    cfg = dict(DEFAULT_CONFIG)\n    if isinstance(data, dict):\n        for k, v in data.items():\n            if v is not None:\n                cfg[k] = v\n\n    bc = (cfg.get(\"browser_cookies\") or \"auto\").strip().lower()\n    allowed = {\n        \"auto\",\n        \"edge\",\n        \"chrome\",\n        \"firefox\",\n        \"brave\",\n        \"vivaldi\",\n        \"opera\",\n        \"chromium\",\n        \"cookiefile\",\n        \"none\",\n    }\n    cfg[\"browser_cookies\"] = bc if bc in allowed else \"auto\"\n\n    return cfg\n\n\ndef load_config() -> dict:\n    try:\n        import json\n        if CONFIG_PATH.exists():\n            data = json.loads(CONFIG_PATH.read_text(encoding=\"utf-8\"))\n            return _ensure_config_defaults(data)\n    except Exception:\n        pass\n    return _ensure_config_defaults(None)\n\n\ndef save_config(cfg: dict) -> None:\n    try:\n        import json\n        from datetime import datetime, timezone\n\n        merged = _ensure_config_defaults(cfg)\n        merged[\"last_updated\"] = datetime.now(timezone.utc).isoformat().replace(\"+00:00\", \"Z\")\n        CONFIG_PATH.write_text(json.dumps(merged, ensure_ascii=False, indent=2), encoding=\"utf-8\")\n    except Exception:\n        pass\n# PATCH END\nfrom dataclasses import dataclass\nfrom typing import Optional, List, Dict\n\nfrom PySide6.QtCore import (\n    Qt,\n    QThread,\n    Signal,\n    Slot,\n    QUrl,\n    QTimer,\n)\nfrom PySide6.QtGui import QAction, QPalette, QColor, QDesktopServices, QIcon\nfrom PySide6.QtWidgets import (\n    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLineEdit, QPushButton,\n    QListWidget, QListWidgetItem, QFileDialog, QLabel, QComboBox,\n    QProgressBar, QMessageBox, QGroupBox, QTabWidget, QTableWidget,\n    QTableWidgetItem,\n    QAbstractItemView,\n    QSpinBox,\n)\nfrom PySide6.QtWidgets import QTextEdit\n\ntry:\n    from shiboken6 import isValid as _shiboken_is_valid\nexcept Exception:  # pragma: no cover - fallback si shiboken6 absent\n    def _shiboken_is_valid(obj):  # type: ignore[return-type]\n        return obj is not None\n\ntry:\n    from flask import Flask\nexcept ImportError:  # pragma: no cover - dÃ©pend de l'environnement\n    Flask = None  # type: ignore[assignment]\n\ntry:  # thÃ¨me optionnel moderne\n    import qdarktheme\n\n    HAS_QDT = True\nexcept Exception:  # pragma: no cover - dÃ©pend des packages installÃ©s\n    HAS_QDT = False\n\n\n_notification_server_started = False\n_notification_parent_widget = None\n\n\ndef _send_windows_notification(message: str) -> None:\n    if not sys.platform.startswith(\"win\"):\n        return\n    try:\n        from win10toast import ToastNotifier  # optionnel\n        ToastNotifier().show_toast(\"FlowGrab\", message, duration=5, threaded=True)\n        return\n    except Exception:\n        pass\n    try:\n        creationflags = getattr(subprocess, \"CREATE_NO_WINDOW\", 0)\n        subprocess.Popen([\n            \"cmd\",\n            \"/c\",\n            \"msg\",\n            \"*\",\n            message,\n        ], creationflags=creationflags)\n    except Exception:\n        pass\n\n\ndef _is_list_item_valid(item: Optional[QListWidgetItem]) -> bool:\n    try:\n        return bool(item) and _shiboken_is_valid(item)\n    except Exception:\n        return False\n\n\ndef start_notification_server(parent_widget=None) -> None:\n    global _notification_server_started, _notification_parent_widget\n    if _notification_server_started:\n        return\n\n    _notification_parent_widget = parent_widget\n\n    if Flask is None:\n        def warn_missing_flask():\n            parent = _notification_parent_widget\n            QMessageBox.warning(\n                parent,\n                \"Flask manquant\",\n                \"Impossible de dÃ©marrer le serveur de notification.\\n\"\n                \"Installe Flask avec 'pip install flask' pour activer les notifications.\",\n            )\n\n        QTimer.singleShot(0, warn_missing_flask)\n        _notification_server_started = True\n        return\n\n    from flask import request  # import ici pour Ã©viter conflit avec l'import conditionnel global\n    flask_app = Flask(\"flowgrab-notify\")\n    TOKEN = os.environ.get(\"FG_NOTIFY_TOKEN\", \"change_me\")\n\n    @flask_app.get(\"/notify-done\")\n    def notify_done():  # pragma: no cover - exÃ©cutÃ© via requÃªte HTTP\n        if request.args.get(\"token\") != TOKEN:\n            return {\"status\": \"forbidden\"}, 403\n\n        def _purge_transcription_segments_and_audio():\n            try:\n                if TRANSCRIPTION_DIR.exists():\n                    for p in TRANSCRIPTION_DIR.glob(\"audio_partie_*.aac\"):\n                        try:\n                            if p.is_file():\n                                p.unlink()\n                        except Exception:\n                            pass\n                    for p in TRANSCRIPTION_DIR.glob(\"*.mp3\"):\n                        try:\n                            if p.is_file():\n                                p.unlink()\n                        except Exception:\n                            pass\n\n                horizon = time.time() - 3600\n                if AUDIOS_DIR.exists():\n                    for p in AUDIOS_DIR.iterdir():\n                        if not p.is_file():\n                            continue\n                        if p.suffix.lower() not in {\".mp3\", \".m4a\", \".wav\", \".ogg\", \".flac\"}:\n                            continue\n                        try:\n                            stat = p.stat()\n                        except Exception:\n                            continue\n                        if stat.st_size <= 0:\n                            continue\n                        if stat.st_mtime >= horizon:\n                            try:\n                                p.unlink()\n                            except Exception:\n                                pass\n            except Exception:\n                pass\n\n        def show_message_box():\n            parent = _notification_parent_widget\n            if parent is not None and hasattr(parent, \"isVisible\") and not parent.isVisible():\n                parent = None\n            if parent is None:\n                parent = QApplication.activeWindow()\n            QMessageBox.information(parent, \"Notification N8N\", \"La transcription est terminÃ©e.\")\n\n        QTimer.singleShot(0, show_message_box)\n        QTimer.singleShot(0, _purge_transcription_segments_and_audio)\n        threading.Thread(target=_send_windows_notification, args=(\"La transcription est terminÃ©e.\",), daemon=True).start()\n        return {\"status\": \"ok\"}\n\n    def run_flask():  # pragma: no cover - serveur en arriÃ¨re-plan\n        try:\n            flask_app.run(host=\"127.0.0.1\", port=5050, debug=False, use_reloader=False)\n        except Exception as exc:\n            def warn_error():\n                parent = _notification_parent_widget\n                QMessageBox.warning(\n                    parent,\n                    \"Serveur Flask\",\n                    f\"Erreur lors du dÃ©marrage du serveur Flask : {exc}\",\n                )\n\n            QTimer.singleShot(0, warn_error)\n\n    threading.Thread(target=run_flask, daemon=True).start()\n    _notification_server_started = True\nfrom yt_dlp import YoutubeDL\n\n# ---------------------- ModÃ¨le de tÃ¢che ----------------------\n@dataclass\nclass Task:\n    url: str\n    status: str = \"En attente\"\n    filename: str = \"\"\n    total: int = 0\n    downloaded: int = 0\n    speed: float = 0.0\n    eta: Optional[int] = None\n    video_id: Optional[str] = None  # pour nettoyage\n    selected_fmt: Optional[str] = None\n    final_audio_path: Optional[str] = None\n    final_video_path: Optional[str] = None\n    # Telegram\n    source: str = \"ui\"                 # \"ui\" | \"telegram\"\n    chat_id: Optional[int] = None\n\n# ---------------------- Worker de tÃ©lÃ©chargement ----------------------\nclass DownloadWorker(QThread):\n    sig_progress = Signal(object, object, float, int, str)     # downloaded, total, speed, eta, filename\n    sig_status   = Signal(str)                           # statut court\n    sig_done     = Signal(bool, str, dict)               # ok, message/chemin, info dict\n\n    def __init__(self, task: Task, ydl_opts: dict, parent=None):\n        super().__init__(parent)\n        self.task = task\n        self.ydl_opts = ydl_opts\n        self._stop = False\n\n    def stop(self):\n        self._stop = True\n\n    def run(self):\n        captured = {\"fn\": \"\"}\n\n        def hook(d):\n            if self._stop:\n                raise Exception(\"Interrompu par lâ€™utilisateur\")\n            st = d.get(\"status\")\n            if st == \"downloading\":\n                downloaded = int(d.get(\"downloaded_bytes\") or 0)\n                total = int(d.get(\"total_bytes\") or d.get(\"total_bytes_estimate\") or 0)\n                speed = float(d.get(\"speed\") or 0.0)\n                eta   = int(d.get(\"eta\") or 0)\n                fn    = d.get(\"filename\") or self.task.filename or \"\"\n                self.sig_progress.emit(downloaded, total, speed, eta, fn)\n            elif st == \"finished\":\n                captured[\"fn\"] = d.get(\"filename\") or captured[\"fn\"]\n                self.sig_status.emit(f\"TerminÃ© : {captured['fn']}\")\n\n        opts = dict(self.ydl_opts)\n        opts[\"progress_hooks\"] = [hook]\n        opts[\"quiet\"] = True\n        opts[\"no_warnings\"] = True\n        opts[\"logger\"] = YtdlpLogger(lambda msg: self.sig_status.emit(msg))\n\n        cfg = load_config()\n        user_agent = (cfg.get(\"user_agent\") or \"\").strip()\n        headers: dict[str, str] = {}\n        if user_agent:\n            headers = dict(opts.get(\"http_headers\") or {})\n            headers[\"User-Agent\"] = user_agent\n            opts[\"http_headers\"] = headers\n\n        try:\n            url = normalize_url(self.task.url)\n            cookies_path = (cfg.get(\"cookies_path\") or \"\").strip()\n            browser_pref = (cfg.get(\"browser_cookies\") or \"auto\").strip().lower()\n\n            base_opts = dict(opts)\n            base_opts.pop(\"cookiefile\", None)\n            base_opts.pop(\"cookiesfrombrowser\", None)\n\n            def _download_with_opts(local_opts: dict[str, Any]) -> tuple[dict[str, Any], int]:\n                last_exc: Exception | None = None\n                for attempt in range(3):\n                    try:\n                        with YoutubeDL(local_opts) as ydl:\n                            info_inner = ydl.extract_info(url, download=True)\n                            ret = getattr(ydl, \"_download_retcode\", 0) or 0\n                        return info_inner, ret\n                    except Exception as exc:\n                        last_exc = exc\n                        msg = (str(exc) or \"\").lower()\n                        if \"429\" in msg or \"too many requests\" in msg:\n                            self.sig_status.emit(\"yt-dlp : HTTP 429, nouvelle tentativeâ€¦\")\n                            _backoff_sleep(attempt)\n                            continue\n                        raise\n                if last_exc:\n                    raise last_exc\n                return {}, 0\n\n            info: dict[str, Any] = {}\n            retcode = 0\n            dpapi_or_copy_issue = False\n            last_error: Exception | None = None\n            used_no_cookies = False\n            success = False\n\n            pycryptodomex_hint = \"Lecture cookies Firefox impossible : installez 'pycryptodomex' (pip install pycryptodomex).\"\n\n            def try_cookiefile() -> bool:\n                nonlocal info, retcode, opts, last_error\n                if not cookies_path:\n                    return False\n                local_opts = dict(base_opts)\n                local_opts[\"cookiefile\"] = cookies_path\n                local_opts.pop(\"cookiesfrombrowser\", None)\n                try:\n                    info, retcode = _download_with_opts(local_opts)\n                    opts = local_opts\n                    return True\n                except Exception as exc:\n                    last_error = exc\n                    return False\n\n            def try_browser(browser: str, explicit: bool) -> bool:\n                nonlocal info, retcode, opts, last_error, dpapi_or_copy_issue\n                local_opts = dict(base_opts)\n                local_opts[\"cookiesfrombrowser\"] = (browser, None, None, None)\n                try:\n                    info, retcode = _download_with_opts(local_opts)\n                    opts = local_opts\n                    return True\n                except Exception as exc:\n                    last_error = exc\n                    msg = (str(exc) or \"\").lower()\n                    if browser == \"firefox\" and (\"pycryptodomex\" in msg or \"cryptodome\" in msg):\n                        self.sig_status.emit(pycryptodomex_hint)\n                        if explicit:\n                            raise RuntimeError(pycryptodomex_hint)\n                        return False\n                    if _is_dpapi_error(exc) or _is_chrome_copy_error(exc):\n                        dpapi_or_copy_issue = True\n                        return False\n                    raise\n\n            def try_no_cookies() -> bool:\n                nonlocal info, retcode, opts, last_error\n                local_opts = dict(base_opts)\n                local_opts.pop(\"cookiefile\", None)\n                local_opts.pop(\"cookiesfrombrowser\", None)\n                try:\n                    info, retcode = _download_with_opts(local_opts)\n                    opts = local_opts\n                    return True\n                except Exception as exc:\n                    last_error = exc\n                    return False\n\n            if browser_pref == \"cookiefile\":\n                success = try_cookiefile()\n            elif browser_pref == \"none\":\n                success = try_no_cookies()\n                used_no_cookies = True\n            else:\n                browsers = _browser_fallback_order(cfg)\n                explicit = browser_pref in BROWSER_TRY_ORDER\n                for browser in browsers:\n                    if try_browser(browser, explicit):\n                        success = True\n                        break\n\n                if not success and browser_pref == \"auto\" and try_cookiefile():\n                    success = True\n\n            if not success and not used_no_cookies:\n                if dpapi_or_copy_issue:\n                    self.sig_status.emit(\n                        \"Cookies navigateur indisponibles (DPAPI/DB verrouillÃ©e). Passage en mode sans cookies.\"\n                    )\n                success = try_no_cookies()\n                used_no_cookies = True\n\n            if not success:\n                if last_error is not None:\n                    raise last_error\n                raise RuntimeError(\"TÃ©lÃ©chargement impossible : toutes les stratÃ©gies de cookies ont Ã©chouÃ©.\")\n\n            fn = captured[\"fn\"]\n            if not fn and info:\n                try:\n                    rd = (info.get(\"requested_downloads\") or [])\n                    if rd:\n                        fn = rd[0].get(\"filepath\") or rd[0].get(\"filename\") or \"\"\n                except Exception:\n                    pass\n\n            if not info:\n                reused_info = {}\n                if retcode == 0:\n                    try:\n                        reused_info = extract_basic_info(url)\n                    except Exception:\n                        reused_info = {}\n\n                if reused_info and retcode == 0:\n                    video_id = reused_info.get(\"id\") or \"\"\n                    existing = find_existing_outputs(video_id)\n                    if (not video_id) or (not existing.get(\"audio\") and not existing.get(\"video\")):\n                        raise RuntimeError(\n                            \"TÃ©lÃ©chargement dÃ©jÃ  enregistrÃ© dans lâ€™archive mais aucun fichier final nâ€™a Ã©tÃ© retrouvÃ©. \"\n                            \"Supprime lâ€™entrÃ©e correspondante dans archive.txt pour forcer un nouveau tÃ©lÃ©chargement.\"\n                        )\n                    if existing.get(\"audio\"):\n                        self.task.final_audio_path = existing[\"audio\"]\n                    if existing.get(\"video\"):\n                        self.task.final_video_path = existing[\"video\"]\n                    reuse_msg = existing.get(\"audio\") or existing.get(\"video\") or \"DÃ©jÃ  tÃ©lÃ©chargÃ© (archive)\"\n                    if video_id:\n                        self.task.video_id = video_id\n                    self.sig_status.emit(\"DÃ©jÃ  tÃ©lÃ©chargÃ© (archive)\")\n                    self.sig_done.emit(True, reuse_msg, reused_info or {})\n                    return\n\n                raise RuntimeError(\"yt-dlp nâ€™a renvoyÃ© aucune information (URL invalide, vidÃ©o privÃ©e ou cookies requis).\")\n\n            if fn:\n                self.task.filename = fn\n\n            self.sig_done.emit(True, fn or \"TÃ©lÃ©chargement terminÃ©\", info or {})\n        except Exception as e:\n            self.sig_done.emit(False, str(e), {})\n\nclass CommandWorker(QThread):\n    sig_line = Signal(str)      # lignes de log\n    sig_done = Signal(int)      # code retour\n\n    def __init__(self, cmd: list[str], cwd: pathlib.Path | None = None, env: dict | None = None, parent=None):\n        super().__init__(parent)\n        self.cmd = cmd\n        self.cwd = str(cwd) if cwd else None\n        self.env = env\n\n    def run(self):\n        try:\n            proc = subprocess.Popen(\n                self.cmd,\n                cwd=self.cwd,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.STDOUT,\n                text=True,\n                env=self.env,\n                shell=False,\n            )\n            assert proc.stdout is not None\n            for line in proc.stdout:\n                self.sig_line.emit(line.rstrip())\n            proc.wait()\n            self.sig_done.emit(proc.returncode or 0)\n        except Exception as e:\n            self.sig_line.emit(f\"[ERREUR] {e}\")\n            self.sig_done.emit(1)\n\n\nclass InspectWorker(QThread):\n    sig_done  = Signal(str, dict)   # url, info\n    sig_error = Signal(str, str)    # url, message\n\n    def __init__(self, url: str, parent=None):\n        super().__init__(parent)\n        self.url = url\n\n    def run(self):\n        try:\n            info = extract_basic_info(self.url)\n            self.sig_done.emit(self.url, info or {})\n        except Exception as e:\n            self.sig_error.emit(self.url, str(e))\n\n\nclass LongProcWorker(QThread):\n    \"\"\"Lance un processus long (ex: script PowerShell), stream les logs, et permet un stop propre.\"\"\"\n\n    sig_line = Signal(str)     # ligne de log\n    sig_started = Signal(int)  # pid\n    sig_done = Signal(int)     # code retour\n\n    def __init__(self, args: list[str], env: dict | None = None, parent=None):\n        super().__init__(parent)\n        self.args = args\n        self.env = env\n        self.proc: subprocess.Popen | None = None\n\n    def run(self):\n        try:\n            creationflags = 0\n            if sys.platform.startswith(\"win\"):\n                # pour pouvoir envoyer CTRL_BREAK_EVENT et tuer l'arbre si besoin\n                creationflags = getattr(subprocess, \"CREATE_NEW_PROCESS_GROUP\", 0)\n            self.proc = subprocess.Popen(\n                self.args,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.STDOUT,\n                text=True,\n                shell=False,\n                env=self.env,\n                creationflags=creationflags,\n            )\n            assert self.proc.stdout is not None\n            self.sig_started.emit(self.proc.pid or 0)\n            for line in self.proc.stdout:\n                self.sig_line.emit(line.rstrip())\n            self.proc.wait()\n            self.sig_done.emit(self.proc.returncode or 0)\n        except Exception as e:\n            self.sig_line.emit(f\"[ERREUR] {e}\")\n            self.sig_done.emit(1)\n\n    def stop(self):\n        if not self.proc:\n            return\n        # PATCH START: stop propre + wait court\n        try:\n            if sys.platform.startswith(\"win\"):\n                self.proc.send_signal(signal.CTRL_BREAK_EVENT)\n                try:\n                    self.proc.wait(timeout=3)\n                except Exception:\n                    pass\n        except Exception:\n            pass\n        try:\n            self.proc.terminate()\n        except Exception:\n            pass\n        try:\n            subprocess.run([\n                \"taskkill\",\n                \"/PID\",\n                str(self.proc.pid),\n                \"/T\",\n                \"/F\",\n            ], capture_output=True, text=True)\n        except Exception:\n            pass\n        # PATCH END\n\n\ndef _apply_qdarktheme(app: QApplication, theme: str) -> bool:\n    if not HAS_QDT:\n        return False\n    # CompatibilitÃ© avec qdarktheme>=2 (setup_theme) et <2 (load_stylesheet).\n    setup = getattr(qdarktheme, \"setup_theme\", None)\n    if callable(setup):\n        setup(theme)\n        return True\n    loader = getattr(qdarktheme, \"load_stylesheet\", None)\n    if callable(loader):\n        app.setStyleSheet(loader(theme))\n        return True\n    return False\n\n\n# ---------------------- ThÃ¨mes ----------------------\ndef apply_dark_theme(app: QApplication):\n    if _apply_qdarktheme(app, \"dark\"):\n        return\n    app.setStyle(\"Fusion\")\n    palette = QPalette()\n    bg = QColor(30, 30, 30)\n    base = QColor(40, 40, 40)\n    text = QColor(220, 220, 220)\n    disabled = QColor(127, 127, 127)\n    highlight = QColor(53, 132, 228)\n\n    palette.setColor(QPalette.Window, bg)\n    palette.setColor(QPalette.WindowText, text)\n    palette.setColor(QPalette.Base, base)\n    palette.setColor(QPalette.AlternateBase, bg)\n    palette.setColor(QPalette.ToolTipBase, base)\n    palette.setColor(QPalette.ToolTipText, text)\n    palette.setColor(QPalette.Text, text)\n    palette.setColor(QPalette.Button, base)\n    palette.setColor(QPalette.ButtonText, text)\n    palette.setColor(QPalette.BrightText, QColor(255, 0, 0))\n    palette.setColor(QPalette.Highlight, highlight)\n    palette.setColor(QPalette.HighlightedText, QColor(255, 255, 255))\n    palette.setColor(QPalette.Disabled, QPalette.Text, disabled)\n    palette.setColor(QPalette.Disabled, QPalette.ButtonText, disabled)\n    app.setPalette(palette)\n\n\ndef apply_light_theme(app: QApplication):\n    if _apply_qdarktheme(app, \"light\"):\n        return\n    app.setStyle(\"Fusion\")\n    app.setPalette(QApplication.style().standardPalette())\n\n# ---------------------- Utilitaires affichage ----------------------\ndef human_size(n: Optional[float]) -> str:\n    if not n or n <= 0: return \"â€”\"\n    n = float(n)\n    for unit in (\"o\",\"Ko\",\"Mo\",\"Go\",\"To\"):\n        if n < 1024.0:\n            return f\"{n:.1f} {unit}\"\n        n /= 1024.0\n    return f\"{n:.1f} Po\"\n\ndef human_rate(v: float) -> str:\n    if not v: return \"â€”/s\"\n    for unit in (\"o/s\",\"Ko/s\",\"Mo/s\",\"Go/s\"):\n        if v < 1024.0:\n            return f\"{v:.1f} {unit}\"\n        v /= 1024.0\n    return f\"{v:.1f} To/s\"\n\ndef human_eta(s: Optional[int]) -> str:\n    if not s: return \"â€”\"\n    m, sec = divmod(int(s), 60)\n    h, m = divmod(m, 60)\n    if h: return f\"{h:d}h {m:02d}m {sec:02d}s\"\n    if m: return f\"{m:d}m {sec:02d}s\"\n    return f\"{sec:d}s\"\n\n# ---------------------- Inspecteur de formats ----------------------\ndef pick_best_audio(formats: List[dict], mp4_friendly: bool) -> Optional[dict]:\n    audios = [f for f in formats if f.get(\"vcodec\") in (None, \"none\")]\n    if mp4_friendly:\n        preferred = [f for f in audios if (f.get(\"ext\") in (\"m4a\",\"mp4\",\"aac\") or (f.get(\"acodec\",\"\" ).startswith(\"mp4a.\")))]\n        if preferred:\n            return sorted(preferred, key=lambda x: x.get(\"tbr\") or 0, reverse=True)[0]\n    if audios:\n        return sorted(audios, key=lambda x: x.get(\"tbr\") or 0, reverse=True)[0]\n    return None\n\ndef list_video_formats(formats: List[dict], mp4_friendly: bool) -> List[dict]:\n    vids = [f for f in formats if f.get(\"acodec\") in (None, \"none\") and f.get(\"vcodec\") not in (None, \"none\")]\n    if mp4_friendly:\n        vids = [f for f in vids if (f.get(\"ext\") == \"mp4\" or \"avc1\" in (f.get(\"vcodec\") or \"\"))]\n    return sorted(vids, key=lambda x: (x.get(\"height\") or 0, x.get(\"tbr\") or 0), reverse=True)\n\ndef estimate_size(stream: dict, duration: Optional[float]) -> Optional[float]:\n    size = stream.get(\"filesize\") or stream.get(\"filesize_approx\")\n    if size: return float(size)\n    tbr = stream.get(\"tbr\")  # kbps\n    if duration and tbr:\n        return float(tbr) * 1000.0 / 8.0 * float(duration)\n    return None\n\n# ---------------------- Telegram worker ----------------------\nclass TelegramWorker(QThread):\n    # chat_id peut dÃ©passer la taille d'un int 32 bits -> utiliser \"object\"\n    sig_download_requested = Signal(str, str, object, str)  # url, fmt, chat_id, title\n    sig_info = Signal(str)\n\n    def __init__(self, app_config: dict, parent=None):\n        super().__init__(parent)\n        self.app_config = app_config\n        self._loop: asyncio.AbstractEventLoop | None = None\n        self._stop_evt: asyncio.Event | None = None\n        self.app: \"Application | None\" = None\n        self._pending_choices: Dict[str, Dict[str, Any]] = {}\n        self.effective_mode = self._resolve_mode()\n        # Map token -> chemin audio Ã  transcrire (Ã©vite de dÃ©passer la limite Telegram 64o sur callback_data)\n        self._pending_transcriptions: Dict[str, str] = {}\n\n    # ---- helpers ----\n    def _resolve_mode(self) -> str:\n        return \"polling\"\n\n    def send_message(self, chat_id: int | str, text: str, reply_markup: Any = None) -> None:\n        if not self._loop or not self.app:\n            return\n\n        try:\n            chat_ref: int | str = int(chat_id)  # Telegram accepte les entiers Python arbitraires\n        except (TypeError, ValueError):\n            chat_ref = chat_id\n\n        async def _send():\n            try:\n                await self.app.bot.send_message(chat_id=chat_ref, text=text, reply_markup=reply_markup)\n            except Exception as exc:\n                self.sig_info.emit(f\"Envoi message Telegram impossible : {exc}\")\n\n        self._loop.call_soon_threadsafe(lambda: asyncio.create_task(_send()))\n\n    def ask_transcription(self, chat_id: int | str, audio_path: str) -> None:\n        from telegram import InlineKeyboardButton, InlineKeyboardMarkup\n\n        token = secrets.token_urlsafe(8)  # court, sÃ»r, << 64 octets\n        self._pending_transcriptions[token] = audio_path\n        name = os.path.basename(audio_path) or audio_path\n        buttons = [\n            [InlineKeyboardButton(\"ðŸ“ Oui, transcrire\", callback_data=f\"tr:yes:{token}\")],\n            [InlineKeyboardButton(\"â›” Non\", callback_data=f\"tr:no:{token}\")],\n        ]\n        self.send_message(chat_id, f\"Transcrire lâ€™audio tÃ©lÃ©chargÃ© ?\\n{name}\", InlineKeyboardMarkup(buttons))\n\n    # ---- yt-dlp helpers ----\n    def _inspect_url(self, url: str) -> dict:\n        u = normalize_yt(url)\n        ydl_opts = {\n            \"quiet\": True,\n            \"no_warnings\": True,\n            \"retries\": 2,\n            \"socket_timeout\": 15,\n        }\n        with YoutubeDL(ydl_opts) as ydl:\n            info = ydl.extract_info(u, download=False)\n        if info and info.get(\"entries\"):\n            info = info[\"entries\"][0]\n        return info or {}\n\n    def _build_options(self, info: dict) -> Tuple[str, List[Dict[str, Any]]]:\n        formats = info.get(\"formats\") or []\n        duration = info.get(\"duration\")\n        videos = list_video_formats(formats, mp4_friendly=True)\n        audio = pick_best_audio(formats, mp4_friendly=True)\n        title = info.get(\"title\") or info.get(\"fulltitle\") or info.get(\"original_url\") or \"Lien YouTube\"\n        options: List[Dict[str, Any]] = []\n        for vf in videos[:8]:\n            vid_id = vf.get(\"format_id\") or \"\"\n            fmt = vid_id\n            audio_id = \"\"\n            audio_label = \"\"\n            audio_size = None\n            if audio:\n                audio_id = audio.get(\"format_id\") or \"\"\n                if audio_id:\n                    fmt = f\"{vid_id}+{audio_id}\"\n                audio_label = f\"{audio.get('ext','')}/{audio.get('acodec','')}\"\n                audio_size = estimate_size(audio, duration)\n            res = f\"{vf.get('height') or ''}p\"\n            fps = vf.get(\"fps\")\n            vc = f\"{vf.get('ext','')}/{vf.get('vcodec','')}\"\n            vsize = estimate_size(vf, duration)\n            total = (vsize or 0) + (audio_size or 0)\n            parts = [res.strip() or \"â€”\", vc]\n            if fps:\n                parts.insert(1, f\"{fps} fps\")\n            label = \" â€¢ \".join([p for p in parts if p])\n            approx = human_size(total) if total else \"â€”\"\n            detail = label\n            if audio_label:\n                detail += f\" â€¢ Audio {audio_label}\"\n            detail += f\" â€¢ â‰ˆ {approx}\"\n            options.append({\n                \"fmt\": fmt,\n                \"label\": detail,\n            })\n        return title, options\n\n    # ---- PTB callbacks ----\n    async def _cmd_start(self, update, context):\n        msg = update.effective_message\n        if msg:\n            await msg.reply_text(\"Envoie-moi un lien YouTube pour lancer un tÃ©lÃ©chargement.\")\n\n    async def _handle_text(self, update, context):\n        message = update.effective_message\n        if not message:\n            return\n        text = (message.text or \"\").strip()\n        match = YOUTUBE_REGEX.search(text)\n        if not match:\n            await message.reply_text(\"Je nâ€™ai pas reconnu de lien YouTube. Envoie lâ€™URL complÃ¨te.\")\n            return\n        url = normalize_yt(match.group(1))\n        await message.reply_text(\"Analyse du lienâ€¦\")\n        loop = asyncio.get_running_loop()\n        try:\n            info = await loop.run_in_executor(None, self._inspect_url, url)\n        except Exception as exc:\n            self.sig_info.emit(f\"Inspection Telegram Ã©chouÃ©e : {exc}\")\n            await message.reply_text(\"Impossible dâ€™inspecter cette vidÃ©o. RÃ©essaie plus tard.\")\n            return\n\n        title, options = self._build_options(info)\n        if not options:\n            await message.reply_text(\"Aucun format compatible trouvÃ© pour cette vidÃ©o.\")\n            return\n\n        token = secrets.token_urlsafe(4)\n        self._pending_choices[token] = {\n            \"url\": url,\n            \"options\": options,\n            \"title\": title,\n        }\n\n        lines = [f\"Formats disponibles pour Â« {title} Â» :\", \"\"]\n        for idx, opt in enumerate(options, start=1):\n            lines.append(f\"{idx}. {opt['label']}\")\n        lines.append(\"\")\n        lines.append(\"Choisis un format via les boutons ci-dessous.\")\n\n        from telegram import InlineKeyboardButton, InlineKeyboardMarkup\n\n        buttons: List[List[Any]] = []\n        row: List[Any] = []\n        for idx in range(len(options)):\n            row.append(InlineKeyboardButton(str(idx + 1), callback_data=f\"choose:{token}:{idx}\"))\n            if len(row) == 4:\n                buttons.append(row)\n                row = []\n        if row:\n            buttons.append(row)\n\n        markup = InlineKeyboardMarkup(buttons)\n        await message.reply_text(\"\\n\".join(lines), reply_markup=markup)\n\n    async def _handle_callback(self, update, context):\n        query = update.callback_query\n        if not query:\n            return\n        data = query.data or \"\"\n        chat = query.message.chat if query.message else update.effective_chat\n        chat_id = chat.id if chat else None\n\n        if data.startswith(\"choose:\"):\n            parts = data.split(\":\", 2)\n            if len(parts) != 3:\n                await query.answer(\"Choix invalide.\")\n                return\n            token, idx_str = parts[1], parts[2]\n            entry = self._pending_choices.get(token)\n            if not entry:\n                await query.answer(\"Choix expirÃ©.\")\n                try:\n                    await query.edit_message_reply_markup(None)\n                except Exception:\n                    pass\n                return\n            try:\n                idx = int(idx_str)\n            except ValueError:\n                await query.answer(\"Choix invalide.\")\n                return\n            options = entry.get(\"options\") or []\n            if idx < 0 or idx >= len(options):\n                await query.answer(\"Choix invalide.\")\n                return\n            option = options[idx]\n            if chat_id is None:\n                await query.answer(\"Chat introuvable.\")\n                return\n            await query.answer(\"TÃ©lÃ©chargement en coursâ€¦\", show_alert=False)\n            try:\n                await query.edit_message_reply_markup(None)\n            except Exception:\n                pass\n            title = entry.get(\"title\") or \"VidÃ©o\"\n            fmt = option.get(\"fmt\") or \"\"\n            self.sig_download_requested.emit(entry.get(\"url\", \"\"), fmt, chat_id, title)\n            self.send_message(chat_id, f\"Format sÃ©lectionnÃ© : {option.get('label','')}\\nTÃ©lÃ©chargement demandÃ©â€¦\")\n            self._pending_choices.pop(token, None)\n        elif data.startswith(\"tr:yes\"):\n            parts = data.split(\":\", 2)\n            tok = parts[2] if len(parts) == 3 else \"\"\n            audio_path = self._pending_transcriptions.pop(tok, \"\")\n            if not audio_path:\n                await query.answer(\"Lien expirÃ©. Renvoie la vidÃ©o pour rÃ©essayer.\", show_alert=True)\n                return\n            await self._handle_transcription_yes(query, chat_id, audio_path)\n        elif data.startswith(\"tr:no\"):\n            await query.answer(\"OK\", show_alert=False)\n            try:\n                await query.edit_message_reply_markup(None)\n            except Exception:\n                pass\n            if chat_id is not None:\n                self.send_message(chat_id, \"Transcription annulÃ©e.\")\n        else:\n            await query.answer(\"Commande inconnue.\")\n\n    async def _handle_transcription_yes(self, query, chat_id: Optional[int], audio_path: str):\n        if chat_id is None:\n            await query.answer(\"Chat introuvable.\")\n            return\n        webhook_full = (self.app_config.get(\"webhook_full\") or \"\").strip()\n        if not webhook_full:\n            await query.answer(\"Webhook non configurÃ©.\", show_alert=True)\n            self.send_message(chat_id, \"Configure le webhook dans lâ€™app avant de lancer une transcription.\")\n            return\n        await query.answer(\"Envoi en coursâ€¦\", show_alert=False)\n        loop = asyncio.get_running_loop()\n        status, body = await loop.run_in_executor(None, self._post_audio_to_webhook, webhook_full, audio_path)\n        try:\n            await query.edit_message_reply_markup(None)\n        except Exception:\n            pass\n        if status == 0:\n            self.send_message(chat_id, f\"Transcription impossible : {body}\")\n            return\n        snippet = body.strip()\n        if len(snippet) > 400:\n            snippet = snippet[:400] + \"\\n...[tronquÃ©]...\"\n        msg = f\"Transcription lancÃ©e âœ… (HTTP {status})\"\n        if snippet:\n            msg += f\"\\n{snippet}\"\n        self.send_message(chat_id, msg)\n\n    def _post_audio_to_webhook(self, url: str, audio_path: str) -> Tuple[int, str]:\n        try:\n            import requests\n        except ImportError:\n            return 0, \"Le module requests est manquant. Installe-le depuis lâ€™app.\"\n        if not os.path.exists(audio_path):\n            return 0, f\"Fichier introuvable : {audio_path}\"\n        mime, _ = mimetypes.guess_type(audio_path)\n        mime = mime or \"application/octet-stream\"\n        basename = os.path.basename(audio_path)\n        try:\n            with open(audio_path, \"rb\") as handle:\n                files = {\"data\": (basename, handle, mime)}\n                resp = requests.post(url, files=files, timeout=(10, 600))\n            body = resp.text or \"\"\n            return resp.status_code, body\n        except Exception as exc:\n            return 0, str(exc)\n\n    # ---- QThread API ----\n    def run(self):\n        token = (self.app_config.get(\"telegram_token\") or \"\").strip()\n        if not token:\n            self.sig_info.emit(\"Token Telegram manquant : bot non dÃ©marrÃ©.\")\n            return\n\n        if sys.platform.startswith(\"win\"):\n            try:\n                asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n            except Exception:\n                pass\n\n        try:\n            self._loop = asyncio.new_event_loop()\n        except Exception as exc:\n            self.sig_info.emit(f\"Erreur bot Telegram : {exc}\")\n            return\n\n        try:\n            asyncio.set_event_loop(self._loop)\n            self._stop_evt = asyncio.Event()\n            mode = self._resolve_mode()\n            base = (self.app_config.get(\"webhook_base\") or \"\").strip()\n            if mode == \"webhook\" and not base:\n                self.sig_info.emit(\"URL webhook absente, bascule en mode polling.\")\n                mode = \"polling\"\n            self.effective_mode = mode\n            major, minor = _ptb_major_minor()\n            self.sig_info.emit(f\"python-telegram-bot v{major}.{minor}\")\n\n            if mode == \"polling\":\n                self._loop.run_until_complete(self._serve_polling())\n            else:\n                port = int(self.app_config.get(\"telegram_port\") or 8081)\n                self._loop.run_until_complete(self._serve_webhook(base, port))\n        except Exception as exc:\n            self.sig_info.emit(f\"Erreur bot Telegram : {exc}\")\n        finally:\n            if self._loop:\n                try:\n                    self._loop.close()\n                except Exception:\n                    pass\n            self._loop = None\n            self._stop_evt = None\n            self.app = None\n            self._pending_choices.clear()\n            self.sig_info.emit(\"Bot Telegram arrÃªtÃ©.\")\n\n    async def _build_app(self):\n        try:\n            from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters\n        except Exception as exc:\n            raise RuntimeError(f\"Import python-telegram-bot impossible : {exc}\") from exc\n\n        token = (self.app_config.get(\"telegram_token\") or \"\").strip()\n        app = Application.builder().token(token).build()\n        self.app = app\n        app.add_handler(CommandHandler(\"start\", self._cmd_start))\n        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self._handle_text))\n        app.add_handler(CallbackQueryHandler(self._handle_callback))\n        return app\n\n    async def _serve_polling(self):\n        self.sig_info.emit(\"Bot Telegram en initialisation (polling)â€¦\")\n        try:\n            app = await self._build_app()\n        except RuntimeError as exc:\n            self.sig_info.emit(str(exc))\n            return\n        await app.initialize()\n        await app.start()\n        try:\n            await app.bot.delete_webhook(drop_pending_updates=True)\n        except Exception:\n            pass\n\n        if app.updater is None:\n            self.sig_info.emit(\"Updater PTB indisponible : polling impossible.\")\n            try:\n                await app.stop()\n            except Exception:\n                pass\n            try:\n                await app.shutdown()\n            except Exception:\n                pass\n            return\n\n        try:\n            await app.updater.start_polling(drop_pending_updates=False)\n        except Exception as exc:\n            self.sig_info.emit(f\"start_polling a Ã©chouÃ© : {exc}\")\n            try:\n                await app.updater.stop()\n            except Exception:\n                pass\n            try:\n                await app.stop()\n            except Exception:\n                pass\n            try:\n                await app.shutdown()\n            except Exception:\n                pass\n            return\n\n        self.sig_info.emit(\"Bot Telegram dÃ©marrÃ© en mode polling.\")\n        try:\n            if self._stop_evt:\n                await self._stop_evt.wait()\n        finally:\n            try:\n                await app.updater.stop()\n            except Exception:\n                pass\n            try:\n                await app.stop()\n            except Exception:\n                pass\n            try:\n                await app.shutdown()\n            except Exception:\n                pass\n\n    async def _serve_webhook(self, base: str, port: int):\n        self.sig_info.emit(\"Bot Telegram en initialisation (webhook)â€¦\")\n        try:\n            app = await self._build_app()\n        except RuntimeError as exc:\n            self.sig_info.emit(str(exc))\n            return\n\n        await app.initialize()\n        await app.start()\n        token = (self.app_config.get(\"telegram_token\") or \"\").strip()\n        path = f\"tg/{token}\"\n        base = base.rstrip(\"/\")\n        webhook_url = f\"{base}/{path}\" if base else f\"/{path}\"\n\n        try:\n            from telegram import Update\n            await app.bot.set_webhook(url=webhook_url, allowed_updates=Update.ALL_TYPES)\n            await app.start_webhook(\n                listen=\"0.0.0.0\",\n                port=port,\n                url_path=path,\n                webhook_url=webhook_url,\n                drop_pending_updates=True,\n            )\n        except Exception as exc:\n            self.sig_info.emit(f\"Impossible de dÃ©marrer le webhook : {exc}\")\n            try:\n                await app.stop()\n            except Exception:\n                pass\n            try:\n                await app.shutdown()\n            except Exception:\n                pass\n            return\n\n        self.sig_info.emit(f\"Webhook : {webhook_url} (port {port})\")\n        self.sig_info.emit(\"Bot Telegram dÃ©marrÃ© en mode webhook.\")\n        try:\n            if self._stop_evt:\n                await self._stop_evt.wait()\n        finally:\n            try:\n                await app.stop_webhook()\n            except Exception:\n                pass\n            try:\n                await app.stop()\n            except Exception:\n                pass\n            try:\n                await app.shutdown()\n            except Exception:\n                pass\n\n    def stop(self):\n        if self._loop and self._stop_evt:\n            self._loop.call_soon_threadsafe(self._stop_evt.set)\n# ---------------------- Utilitaires de fichiers ----------------------\n_RESERVED = '<>:\"/\\\\|?*'\n\n\ndef sanitize_filename(name: str) -> str:\n    \"\"\"Nettoie un nom de fichier pour le rendre compatible multiplateforme.\"\"\"\n    safe = \"\".join(\"_\" if ch in _RESERVED else ch for ch in name)\n    safe = re.sub(r\"\\s+\", \" \", safe).strip()\n    if len(safe) > 150:\n        safe = safe[:150].rstrip()\n    return safe or \"file\"\n\n\ndef _unique_path(dst: pathlib.Path) -> pathlib.Path:\n    \"\"\"\n    Retourne un chemin libre en ajoutant -1, -2, ... si 'dst' existe dÃ©jÃ .\n    \"\"\"\n    if not dst.exists():\n        return dst\n    stem, suffix = dst.stem, dst.suffix\n    i = 1\n    while True:\n        cand = dst.with_name(f\"{stem}-{i}{suffix}\")\n        if not cand.exists():\n            return cand\n        i += 1\n\n\ndef ensure_audio(task: Task) -> Optional[str]:\n    \"\"\"Garantit la prÃ©sence d'un MP3 exploitable pour la transcription.\"\"\"\n\n    if task.final_audio_path and os.path.exists(task.final_audio_path):\n        return task.final_audio_path\n    if not task.final_video_path or not os.path.exists(task.final_video_path):\n        return None\n    if not shutil.which(\"ffmpeg\"):\n        return None\n\n    src = pathlib.Path(task.final_video_path)\n    base = src.stem\n    safe_base = sanitize_filename(base)\n    dst = _unique_path(AUDIOS_DIR / f\"{safe_base}.mp3\")\n\n    try:\n        proc = subprocess.run(\n            [\n                \"ffmpeg\",\n                \"-y\",\n                \"-i\",\n                str(src),\n                \"-vn\",\n                \"-acodec\",\n                \"libmp3lame\",\n                \"-b:a\",\n                \"192k\",\n                str(dst),\n            ],\n            capture_output=True,\n            text=True,\n        )\n        if proc.returncode == 0 and dst.exists():\n            task.final_audio_path = str(dst)\n            return task.final_audio_path\n    except Exception:\n        pass\n    return None\n\n\ndef themed_icon(*names: str) -> QIcon:\n    for name in names:\n        icon = QIcon.fromTheme(name)\n        if not icon.isNull():\n            return icon\n    return QIcon()\n\n\ndef _is_merge_in_progress(repo: pathlib.Path) -> bool:\n    return (repo / \".git\" / \"MERGE_HEAD\").exists()\n\n\ndef find_existing_outputs(video_id: str) -> dict:\n    \"\"\"Cherche des fichiers audio/vidÃ©o dÃ©jÃ  produits pour l'ID donnÃ©.\"\"\"\n    found = {\"audio\": None, \"video\": None}\n    if not video_id:\n        return found\n\n    token = f\"[{video_id}]\"\n\n    def _pick_latest(paths: list[pathlib.Path]) -> Optional[pathlib.Path]:\n        if not paths:\n            return None\n        try:\n            return max(paths, key=lambda p: p.stat().st_mtime)\n        except Exception:\n            return paths[0]\n\n    audio_exts = {\".mp3\", \".m4a\", \".wav\", \".ogg\", \".flac\"}\n    video_exts = {\".mp4\", \".mkv\", \".webm\", \".mov\"}\n\n    try:\n        audio_candidates = [\n            p for p in AUDIOS_DIR.glob(f\"*{token}*\")\n            if p.is_file() and p.suffix.lower() in audio_exts\n        ]\n        video_candidates = [\n            p for p in VIDEOS_DIR.glob(f\"*{token}*\")\n            if p.is_file() and p.suffix.lower() in video_exts\n        ]\n\n        audio_path = _pick_latest(audio_candidates)\n        video_path = _pick_latest(video_candidates)\n        if audio_path:\n            found[\"audio\"] = str(audio_path)\n        if video_path:\n            found[\"video\"] = str(video_path)\n    except Exception:\n        pass\n\n    return found\n\n\ndef move_final_outputs(task: Task) -> dict:\n    \"\"\"\n    DÃ©place les fichiers finaux (.mp4, .mp3) du sous-dossier 'Titre [ID]'\n    vers 'Videos' et 'Audios' (Ã  plat). GÃ¨re les collisions de noms.\n    \"\"\"\n    moved = {\"audio\": None, \"video\": None}\n    if not task.video_id or not task.filename:\n        return moved\n\n    try:\n        src_dir = pathlib.Path(task.filename).parent\n        token = f\"[{task.video_id}]\"\n\n        for p in list(src_dir.glob(f\"*{token}*\")):\n            if not p.is_file():\n                continue\n            ext = p.suffix.lower()\n\n            # â›” 1) Ne PAS dÃ©placer les flux audio bruts (intermÃ©diaires)\n            if ext in {\".m4a\", \".aac\", \".wav\", \".ogg\", \".flac\"}:\n                continue\n\n            # â›” 2) Ne PAS dÃ©placer les .mp4 intermÃ©diaires (.fNNN.mp4)\n            if ext == \".mp4\" and \".f\" in p.stem:\n                continue\n\n            # âœ… 3) On ne s'occupe que des fichiers finaux utiles\n            if ext not in (\".mp4\", \".mp3\", \".mkv\", \".webm\", \".mov\"):\n                continue\n\n            stem = p.stem\n            token_segment = \"\"\n            if \"[\" in stem and \"]\" in stem:\n                start = stem.rfind(\"[\")\n                end = stem.rfind(\"]\")\n                if start >= 0 and end > start:\n                    token_segment = stem[start : end + 1]\n\n            # Dossier cible (audios vs vidÃ©os)\n            if ext == \".mp3\":\n                base_dir = AUDIOS_DIR\n            else:\n                base_dir = VIDEOS_DIR\n\n            # Construction d'un nom sÃ»r et stable\n            prefix = stem\n            if token_segment:\n                prefix = stem.replace(token_segment, \"\").strip()\n            safe_prefix = sanitize_filename(prefix)\n            if token_segment:\n                safe_stem = (safe_prefix + (\" \" if safe_prefix else \"\") + token_segment).strip()\n            else:\n                safe_stem = safe_prefix\n            safe_name = f\"{safe_stem}{ext}\"\n            dst = _unique_path(base_dir / safe_name)\n\n            try:\n                p.replace(dst)\n            except Exception:\n                shutil.move(str(p), str(dst))\n\n            if base_dir == VIDEOS_DIR:\n                moved[\"video\"] = str(dst)\n                task.final_video_path = str(dst)\n            else:\n                moved[\"audio\"] = str(dst)\n                task.final_audio_path = str(dst)\n    except Exception:\n        pass\n    return moved\n\n\ndef cleanup_orphans_in_outputs(task: Task):\n    \"\"\"Supprime des sorties finales les fichiers intermÃ©diaires orphelins dÃ©jÃ  dÃ©placÃ©s par erreur.\"\"\"\n    if not task.video_id:\n        return\n    token = f\"[{task.video_id}]\"\n    try:\n        for p in AUDIOS_DIR.glob(f\"*{token}*\"):\n            if not p.is_file():\n                continue\n            ext = p.suffix.lower()\n            if ext == \".m4a\" or (ext == \".mp4\" and \".f\" in p.stem) or ext in {\".aac\", \".wav\", \".ogg\", \".flac\"}:\n                try:\n                    p.unlink()\n                except Exception:\n                    pass\n    except Exception:\n        pass\n\n\ndef delete_dir_if_empty(path: pathlib.Path):\n    \"\"\"\n    Supprime 'path' s'il est vide (ignore erreurs).\n    \"\"\"\n    try:\n        if path.is_dir():\n            # re-liste aprÃ¨s les dÃ©placements / nettoyages\n            if not any(path.iterdir()):\n                path.rmdir()\n    except Exception:\n        pass\n\n# ---------------------- Onglet YouTube ----------------------\n\nclass YoutubeTab(QWidget):\n    sig_request_transcription = Signal(list)\n    # chat_id peut dÃ©passer la taille d'un int 32 bits -> utiliser \"object\"\n    sig_audio_completed = Signal(object, str)  # chat_id, audio_path\n\n    def __init__(self, app_ref, parent=None):\n        super().__init__(parent)\n        self.setAcceptDrops(True)\n        self.app_ref = app_ref\n        self.queue: List[Task] = []\n        self.current_worker: Optional[DownloadWorker] = None\n        self.last_inspect_info: Dict = {}\n        self.inspect_worker = None\n        self.inspect_seq = 0            # numÃ©ro de requÃªte pour ignorer les rÃ©ponses obsolÃ¨tes\n        self.inspect_debounce = QTimer(self)\n        self.inspect_debounce.setSingleShot(True)\n        self.inspect_debounce.setInterval(250)  # 250ms de debounce\n        self.inspect_debounce.timeout.connect(self._inspect_current_after_debounce)\n        self.build_ui()\n\n    # PATCH START: helper curseur attente + usage\n    def _cursor_wait(self, on: bool):\n        if on and QApplication.overrideCursor() is None:\n            QApplication.setOverrideCursor(Qt.WaitCursor)\n        elif not on:\n            try:\n                QApplication.restoreOverrideCursor()\n            except Exception:\n                pass\n\n    def _open_dir(self, path: pathlib.Path):\n        try:\n            os.startfile(str(path))  # type: ignore[attr-defined]\n        except AttributeError:\n            QDesktopServices.openUrl(QUrl.fromLocalFile(str(path)))\n        except Exception as e:\n            QMessageBox.warning(self, \"Erreur\", f\"Impossible dâ€™ouvrir le dossier : {e}\")\n    # PATCH END\n\n    def build_ui(self):\n        root = QVBoxLayout(self)\n        root.setContentsMargins(12, 12, 12, 12)\n        root.setSpacing(8)\n\n        # ----- URLs + Inspecteur -----\n        urls_box = QGroupBox(\"URLs\")\n        urls_layout = QVBoxLayout(urls_box)\n        urls_layout.setContentsMargins(12, 12, 12, 12)\n        urls_layout.setSpacing(8)\n\n        add_line = QHBoxLayout()\n        add_line.setSpacing(8)\n        self.edit_url = QLineEdit()\n        self.edit_url.setPlaceholderText(\"Colle une URL YouTube/playlist et presse EntrÃ©e pour lâ€™ajouter\")\n        self.edit_url.returnPressed.connect(self.add_url)\n        btn_add = QPushButton(\"Ajouter\")\n        icon_add = themed_icon(\"list-add\", \"document-new\")\n        if not icon_add.isNull():\n            btn_add.setIcon(icon_add)\n        btn_add.clicked.connect(self.add_url)\n        btn_paste = QPushButton(\"Coller URL\")\n        icon_paste = themed_icon(\"edit-paste\")\n        if not icon_paste.isNull():\n            btn_paste.setIcon(icon_paste)\n        btn_paste.clicked.connect(self.paste_clipboard)\n        btn_file = QPushButton(\"Depuis .txt\")\n        icon_file = themed_icon(\"document-open\", \"text-x-generic\")\n        if not icon_file.isNull():\n            btn_file.setIcon(icon_file)\n        btn_file.clicked.connect(self.add_from_file)\n        btn_clear_urls = QPushButton(\"Vider la liste\")\n        icon_clear = themed_icon(\"edit-clear\", \"user-trash\")\n        if not icon_clear.isNull():\n            btn_clear_urls.setIcon(icon_clear)\n        btn_clear_urls.clicked.connect(self.clear_url_list)\n        btn_open = QPushButton(\"Ouvrir le dossier\")\n        icon_open = themed_icon(\"folder-open\")\n        if not icon_open.isNull():\n            btn_open.setIcon(icon_open)\n        btn_open.clicked.connect(self.open_output_dir)\n        btn_open_v = QPushButton(\"Ouvrir VidÃ©os\")\n        if not icon_open.isNull():\n            btn_open_v.setIcon(icon_open)\n        btn_open_v.clicked.connect(lambda: self._open_dir(VIDEOS_DIR))\n        btn_open_a = QPushButton(\"Ouvrir Audios\")\n        if not icon_open.isNull():\n            btn_open_a.setIcon(icon_open)\n        btn_open_a.clicked.connect(lambda: self._open_dir(AUDIOS_DIR))\n        add_line.addWidget(self.edit_url, 1)\n        add_line.addWidget(btn_add)\n        add_line.addWidget(btn_paste)\n        add_line.addWidget(btn_file)\n        add_line.addWidget(btn_clear_urls)\n        add_line.addWidget(btn_open)\n        add_line.addWidget(btn_open_v)\n        add_line.addWidget(btn_open_a)\n        urls_layout.addLayout(add_line)\n\n        self.list = QListWidget()\n        self.list.setContextMenuPolicy(Qt.ActionsContextMenu)\n        act_del = QAction(\"Supprimer la sÃ©lection\", self)\n        act_del.triggered.connect(self.delete_selected)\n        self.list.addAction(act_del)\n        self.list.currentItemChanged.connect(self.on_current_item_changed)\n        urls_layout.addWidget(self.list)\n\n        # Tableau formats\n        self.tbl = QTableWidget(0, 10)\n        self.tbl.setHorizontalHeaderLabels(\n            [\n                \"âœ”\",\n                \"ID video\",\n                \"RÃ©solution\",\n                \"FPS\",\n                \"Ext/VC\",\n                \"Poids vidÃ©o\",\n                \"ID audio\",\n                \"Audio\",\n                \"Poids audio\",\n                \"Total estimÃ©\",\n            ]\n        )\n        self.tbl.setSelectionBehavior(QAbstractItemView.SelectRows)\n        self.tbl.setEditTriggers(QAbstractItemView.NoEditTriggers)\n        self.tbl.setSelectionMode(QAbstractItemView.SingleSelection)\n        self.tbl.horizontalHeader().setStretchLastSection(True)\n        self.tbl.itemDoubleClicked.connect(self.on_format_double_click)\n        urls_layout.addWidget(self.tbl)\n\n        # ----- ContrÃ´les -----\n        ctrl = QHBoxLayout()\n        ctrl.setSpacing(8)\n        self.btn_start = QPushButton(\"DÃ©marrer\")\n        icon_start = themed_icon(\"media-playback-start\", \"system-run\")\n        if not icon_start.isNull():\n            self.btn_start.setIcon(icon_start)\n        self.btn_start.clicked.connect(self.start_queue)\n        self.btn_stop = QPushButton(\"Stop\")\n        icon_stop = themed_icon(\"media-playback-stop\", \"process-stop\")\n        if not icon_stop.isNull():\n            self.btn_stop.setIcon(icon_stop)\n        self.btn_stop.clicked.connect(self.stop_current)\n        ctrl.addWidget(self.btn_start)\n        ctrl.addWidget(self.btn_stop)\n        ctrl.addStretch(1)\n        urls_layout.addLayout(ctrl)\n        root.addWidget(urls_box)\n\n        # ----- Statuts -----\n        stat_line = QHBoxLayout()\n        stat_line.setSpacing(8)\n        self.lab_name = QLabel(\"Fichier : â€”\")\n        self.lab_speed = QLabel(\"Vitesse : â€”\")\n        self.lab_size = QLabel(\"Taille : â€”\")\n        self.lab_eta = QLabel(\"ETA : â€”\")\n        stat_line.addWidget(self.lab_name, 3)\n        stat_line.addWidget(self.lab_speed, 1)\n        stat_line.addWidget(self.lab_size, 1)\n        stat_line.addWidget(self.lab_eta, 1)\n        root.addLayout(stat_line)\n\n        self.bar = QProgressBar()\n        self.bar.setRange(0, 100)\n        self.bar.setValue(0)\n        root.addWidget(self.bar)\n\n        self.setMinimumWidth(1080)\n\n    def open_output_dir(self):\n        path = OUT_DIR\n        self._open_dir(path)\n\n    def clear_url_list(self):\n        self.queue.clear()\n        self.list.clear()\n\n    def append_task(self, url: str):\n        t = Task(url=url)\n        self.queue.append(t)\n        item = QListWidgetItem(f\"[En attente] {url}\")\n        item.setData(Qt.UserRole, t)\n        self.list.addItem(item)\n        return item\n\n    def find_item_for_task(self, task: Task) -> Optional[QListWidgetItem]:\n        for idx in range(self.list.count()):\n            candidate = self.list.item(idx)\n            if candidate and candidate.data(Qt.UserRole) is task:\n                return candidate\n        return None\n\n    def _ensure_task_item(self, item: Optional[QListWidgetItem], task: Task) -> Optional[QListWidgetItem]:\n        if _is_list_item_valid(item):\n            return item\n        return self.find_item_for_task(task)\n\n    def add_url(self):\n        url = self.edit_url.text().strip()\n        if not url:\n            return\n        for i in range(self.list.count()):\n            exist_task: Task = self.list.item(i).data(Qt.UserRole)\n            if exist_task and exist_task.url == url:\n                QMessageBox.information(self, \"DÃ©jÃ  prÃ©sent\", \"Cette URL est dÃ©jÃ  dans la liste.\")\n                self.edit_url.clear()\n                return\n        item = self.append_task(url)\n        self.list.setCurrentItem(item)\n        self.inspect_task_async(item)\n        self.edit_url.clear()\n\n    def paste_clipboard(self):\n        cb = QApplication.clipboard()\n        if not cb:\n            return\n        text = (cb.text() or \"\").strip()\n        if not text:\n            return\n        match = YOUTUBE_REGEX.search(text)\n        if match:\n            self.edit_url.setText(match.group(1))\n            self.add_url()\n\n    def add_from_file(self):\n        p, _ = QFileDialog.getOpenFileName(self, \"Fichier .txt\", \"\", \"Text (*.txt)\")\n        if not p: return\n        new_items: List[QListWidgetItem] = []\n        for line in pathlib.Path(p).read_text(encoding=\"utf-8\").splitlines():\n            u = line.strip()\n            if not u: continue\n            exists = False\n            for i in range(self.list.count()):\n                exist_task: Task = self.list.item(i).data(Qt.UserRole)\n                if exist_task and exist_task.url == u:\n                    exists = True\n                    break\n            if exists:\n                continue\n            new_items.append(self.append_task(u))\n        if new_items:\n            item = new_items[0]\n            self.list.setCurrentItem(item)\n            self.inspect_task_async(item)\n\n    def dragEnterEvent(self, e):\n        if e.mimeData().hasUrls() or e.mimeData().hasText():\n            e.acceptProposedAction()\n\n    def dropEvent(self, e):\n        urls: list[str] = []\n        if e.mimeData().hasUrls():\n            for url in e.mimeData().urls():\n                path = url.toLocalFile() or url.toString()\n                if not path:\n                    continue\n                if path.lower().endswith(\".txt\"):\n                    try:\n                        for line in pathlib.Path(path).read_text(encoding=\"utf-8\").splitlines():\n                            if line.strip():\n                                urls.append(line.strip())\n                    except Exception:\n                        pass\n                else:\n                    urls.append(path)\n        if e.mimeData().hasText():\n            urls.append(e.mimeData().text())\n        for raw in urls:\n            if not raw:\n                continue\n            match = YOUTUBE_REGEX.search(raw.strip())\n            if match:\n                self.edit_url.setText(match.group(1))\n                self.add_url()\n        e.acceptProposedAction()\n\n    def delete_selected(self):\n        for it in self.list.selectedItems():\n            t: Task = it.data(Qt.UserRole)\n            if t in self.queue: self.queue.remove(t)\n            self.list.takeItem(self.list.row(it))\n\n    # ---------- Inspecteur ----------\n    def on_current_item_changed(self, current: QListWidgetItem, previous: QListWidgetItem):\n        # Debounce pour Ã©viter de spammer lâ€™inspect quand on navigue vite\n        self.inspect_debounce.start()\n\n    def _inspect_current_after_debounce(self):\n        item = self.list.currentItem()\n        if item:\n            self.inspect_task_async(item)\n\n    def inspect_task_async(self, item: QListWidgetItem):\n        \"\"\"DÃ©marre l'inspection en arriÃ¨re-plan pour l'item donnÃ©.\"\"\"\n        task: Task = item.data(Qt.UserRole)\n        if not task or not task.url:\n            return\n\n        # UI: Ã©tat \"Analyseâ€¦\"\n        self.tbl.setRowCount(0)\n        self.statusBar(\"Analyse des formatsâ€¦\")\n        self._cursor_wait(True)\n        self.btn_start.setEnabled(False)\n\n        # numÃ©ro de sÃ©quence pour ignorer les rÃ©ponses tardives\n        self.inspect_seq += 1\n        seq = self.inspect_seq\n\n        # tuer le worker prÃ©cÃ©dent s'il existe (on n'a pas d'annulation \"forte\" sur yt-dlp, mais on Ã©vite de mÃ©langer les signaux)\n        if self.inspect_worker and self.inspect_worker.isRunning():\n            pass\n\n        w = InspectWorker(task.url, self)\n        self.inspect_worker = w\n        w.sig_done.connect(lambda url, info, s=seq: self.on_inspect_done(s, item, url, info))\n        w.sig_error.connect(lambda url, msg, s=seq: self.on_inspect_error(s, item, url, msg))\n        w.start()\n\n\n    def on_inspect_done(self, seq: int, item: QListWidgetItem, url: str, info: dict):\n        # ignorer si une requÃªte plus rÃ©cente a Ã©tÃ© lancÃ©e\n        if seq != self.inspect_seq:\n            return\n\n        self.last_inspect_info = info or {}\n        formats = self.last_inspect_info.get(\"formats\") or []\n        duration = self.last_inspect_info.get(\"duration\")\n\n        vlist = list_video_formats(formats, mp4_friendly=True)\n        abest = pick_best_audio(formats, mp4_friendly=True)\n\n        self.tbl.setRowCount(0)\n        task: Task = item.data(Qt.UserRole)\n\n        for vf in vlist:\n            vid_id = vf.get(\"format_id\") or \"\"\n            res = f\"{vf.get('height') or ''}p\"\n            fps = vf.get(\"fps\") or \"\"\n            vc = f\"{vf.get('ext','')}/{vf.get('vcodec','')}\"\n            vsize = estimate_size(vf, duration)\n\n            if abest:\n                aid = abest.get(\"format_id\") or \"\"\n                aname = f\"{abest.get('ext','')}/{abest.get('acodec','')}\"\n                asize = estimate_size(abest, duration)\n            else:\n                aid, aname, asize = \"\", \"\", None\n\n            total = (vsize or 0) + (asize or 0)\n\n            row = self.tbl.rowCount()\n            self.tbl.insertRow(row)\n\n            # Colonne 0 : point vert si format dÃ©jÃ  choisi\n            chosen = f\"{vid_id}+{aid}\" if aid else vid_id\n            dot_item = QTableWidgetItem(\"â—\" if task and task.selected_fmt == chosen else \"\")\n            dot_item.setTextAlignment(Qt.AlignCenter)\n            if dot_item.text():\n                dot_item.setForeground(QColor(0, 170, 0))\n            self.tbl.setItem(row, 0, dot_item)\n\n            values = [vid_id, res, str(fps), vc, human_size(vsize), aid, aname, human_size(asize), human_size(total)]\n            for col, val in enumerate(values, start=1):\n                self.tbl.setItem(row, col, QTableWidgetItem(val))\n\n        self.tbl.resizeColumnsToContents()\n        title = self.last_inspect_info.get(\"title\") or \"â€”\"\n        duration = self.last_inspect_info.get(\"duration\") or 0\n        dur_txt = human_eta(int(duration)) if duration else \"â€”\"\n        self.statusBar(f\"Formats prÃªts â€” {title} ({dur_txt})\")\n        self._cursor_wait(False)\n        self.btn_start.setEnabled(True)\n        self.inspect_worker = None\n\n\n    def on_inspect_error(self, seq: int, item: QListWidgetItem, url: str, msg: str):\n        # ignorer si une requÃªte plus rÃ©cente a Ã©tÃ© lancÃ©e\n        if seq != self.inspect_seq:\n            return\n        self._cursor_wait(False)\n        self.btn_start.setEnabled(True)\n        self.statusBar(\"Ã‰chec de lâ€™analyse\")\n        QMessageBox.warning(self, \"Erreur\", f\"Impossible dâ€™inspecter : {msg}\")\n        if \"429\" in msg or \"Too Many Requests\" in msg:\n            QMessageBox.warning(self, \"Limite atteinte\",\n                                \"YouTube a limitÃ© lâ€™inspection (429). RÃ©essaie dans ~1 minute.\")\n        self.inspect_worker = None\n\n    def on_format_double_click(self, it: QTableWidgetItem):\n        row = it.row()\n        item = self.list.currentItem()\n        if not item or row < 0:\n            return\n        task: Task = item.data(Qt.UserRole)\n        if not task:\n            return\n\n        vid_item = self.tbl.item(row, 1)\n        if not vid_item:\n            return\n        vid = vid_item.text().strip()\n        aid_item = self.tbl.item(row, 6)\n        aid = aid_item.text().strip() if aid_item else \"\"\n        chosen = f\"{vid}+{aid}\" if aid else vid\n        task.selected_fmt = chosen\n\n        for r in range(self.tbl.rowCount()):\n            di = self.tbl.item(r, 0)\n            if di is None:\n                di = QTableWidgetItem(\"\")\n                di.setTextAlignment(Qt.AlignCenter)\n                self.tbl.setItem(r, 0, di)\n            else:\n                di.setText(\"\")\n                di.setTextAlignment(Qt.AlignCenter)\n                di.setForeground(QColor())\n\n        ok = self.tbl.item(row, 0)\n        if ok is None:\n            ok = QTableWidgetItem(\"\")\n            self.tbl.setItem(row, 0, ok)\n        ok.setText(\"â—\")\n        ok.setTextAlignment(Qt.AlignCenter)\n        ok.setForeground(QColor(0, 170, 0))\n\n        self.statusBar(f\"Format choisi : {chosen}\")\n\n    # ---------- Options yt-dlp ----------\n    def build_opts(self, task: Task):\n        outdir = OUT_DIR\n        fmt = task.selected_fmt or \"bestvideo[ext=mp4][vcodec*=avc1]+bestaudio[ext=m4a]/best[ext=mp4]\"\n\n        folder_tmpl = \"%(title).200s [%(id)s]\"\n        file_tmpl = \"%(title).200s [%(id)s].%(ext)s\"\n        outtmpl = str(outdir / folder_tmpl / file_tmpl)\n\n        opts = {\n            \"outtmpl\": outtmpl,\n            \"windowsfilenames\": True,\n            \"format\": fmt,\n            \"merge_output_format\": \"mp4\",\n            \"postprocessors\": [\n                {\"key\": \"FFmpegVideoRemuxer\", \"preferedformat\": \"mp4\"},\n                {\"key\": \"FFmpegExtractAudio\", \"preferredcodec\": \"mp3\", \"preferredquality\": \"192\"},\n            ],\n            # IMPORTANT: garder la vidÃ©o aprÃ¨s l'extraction audio\n            \"keepvideo\": True,\n            \"quiet\": True,\n            \"no_warnings\": True,\n            \"continuedl\": True,\n            \"concurrent_fragment_downloads\": 4,\n            \"noplaylist\": True,\n            \"download_archive\": str(DOWNLOAD_ARCHIVE),\n            \"nooverwrites\": True,\n            \"overwrites\": False,\n        }\n        return opts\n\n    # ---------- File dâ€™attente ----------\n    def start_queue(self):\n        if self.list.count() == 0 and self.edit_url.text().strip():\n            self.add_url()\n\n        if self.current_worker and self.current_worker.isRunning():\n            QMessageBox.information(self, \"DÃ©jÃ  en cours\", \"Un tÃ©lÃ©chargement est dÃ©jÃ  en cours.\")\n            return\n\n        # PATCH START: vÃ©rif FFmpeg\n        if not shutil.which(\"ffmpeg\") or not shutil.which(\"ffprobe\"):\n            QMessageBox.warning(\n                self,\n                \"FFmpeg manquant\",\n                \"Installe FFmpeg avant de tÃ©lÃ©charger (ex: winget install Gyan.FFmpeg).\",\n            )\n            return\n        # PATCH END\n\n        next_task = None\n        for i in range(self.list.count()):\n            it = self.list.item(i)\n            t: Task = it.data(Qt.UserRole)\n            if t.status in (\"En attente\", \"Erreur\"):\n                next_task = (i, it, t); break\n        if not next_task:\n            QMessageBox.information(self, \"Info\", \"Aucune tÃ¢che en attente.\")\n            return\n\n        _, item, task = next_task\n        task.status = \"En cours\"\n        safe_item = self._ensure_task_item(item, task)\n        if _is_list_item_valid(safe_item):\n            safe_item.setText(f\"[En cours] {task.url}\")\n\n        opts = self.build_opts(task)\n        self.current_worker = DownloadWorker(task, opts, self)\n        self.current_worker.sig_progress.connect(lambda d, tot, sp, eta, fn: self.on_progress(safe_item, task, d, tot, sp, eta, fn))\n        self.current_worker.sig_status.connect(self.statusBar)\n        self.current_worker.sig_done.connect(lambda ok, msg, info: self.on_done(safe_item, task, ok, msg, info))\n        self.btn_start.setEnabled(False)\n        self.current_worker.start()\n\n    def stop_current(self):\n        if self.current_worker and self.current_worker.isRunning():\n            self.current_worker.stop()\n\n    @Slot()\n    def on_progress(self, item: QListWidgetItem, task: Task, downloaded: int, total: int, speed: float, eta: int, filename: str):\n        task.downloaded, task.total, task.speed, task.eta = downloaded, total, speed, eta\n        if filename: task.filename = filename\n        pct = int(downloaded * 100 / total) if total else 0\n        self.bar.setValue(pct)\n        name = pathlib.Path(task.filename).name if task.filename else \"â€”\"\n        self.lab_name.setText(f\"Fichier : {name}\")\n        self.lab_speed.setText(f\"Vitesse : {human_rate(speed)}\")\n        self.lab_size.setText(f\"Taille : {human_size(downloaded)} / {human_size(total)}\")\n        self.lab_eta.setText(f\"ETA : {human_eta(eta)}\")\n        safe_item = self._ensure_task_item(item, task)\n        if _is_list_item_valid(safe_item):\n            safe_item.setText(f\"[{pct:>3}%] {task.url}\")\n\n    @Slot()\n    def on_done(self, item: QListWidgetItem, task: Task, ok: bool, msg: str, info: dict):\n        safe_item = self._ensure_task_item(item, task)\n        if ok:\n            task.status = \"TerminÃ©\"\n            if _is_list_item_valid(safe_item):\n                safe_item.setText(f\"[TerminÃ©] {task.url}\")\n            self.statusBar(f\"TerminÃ© : {msg}\")\n            task.video_id = (info or {}).get(\"id\")\n            moved = move_final_outputs(task)\n            self.cleanup_residuals(task)\n            cleanup_orphans_in_outputs(task)\n            try:\n                if task.filename:\n                    subdir = OUT_DIR / pathlib.Path(task.filename).parent.name\n                    delete_dir_if_empty(subdir)\n            except Exception:\n                pass\n\n            audio_path = moved.get(\"audio\") or task.final_audio_path\n            if not audio_path:\n                audio_path = ensure_audio(task)\n                if audio_path:\n                    self.statusBar(\"Audio gÃ©nÃ©rÃ© depuis la vidÃ©o pour transcription\")\n            if task.source == \"telegram\" and task.chat_id and audio_path:\n                self.sig_audio_completed.emit(task.chat_id, audio_path)\n            elif audio_path:\n                reply = QMessageBox.question(\n                    self,\n                    \"Transcription\",\n                    \"Voulez-vous transcrire lâ€™audio tÃ©lÃ©chargÃ© ?\",\n                    QMessageBox.Yes | QMessageBox.No,\n                )\n                if reply == QMessageBox.Yes:\n                    self.sig_request_transcription.emit([audio_path])\n        else:\n            task.status = \"Erreur\"\n            if _is_list_item_valid(safe_item):\n                safe_item.setText(f\"[Erreur] {task.url}\")\n            if task.source == \"telegram\" and task.chat_id:\n                main = self.window()\n                worker = getattr(main, \"telegram_worker\", None)\n                if worker:\n                    worker.send_message(task.chat_id, f\"Ã‰chec du tÃ©lÃ©chargement : {msg}\")\n            else:\n                QMessageBox.warning(self, \"Erreur\", f\"Ã‰chec du tÃ©lÃ©chargement :\\n{msg}\")\n        self.bar.setValue(0)\n        self.current_worker = None\n        self.btn_start.setEnabled(True)\n        QTimer.singleShot(200, self.start_queue)\n        return\n\n    def statusBar(self, text: str):\n        self.window().setWindowTitle(f\"FlowGrab â€” {text}\")\n\n    def cleanup_residuals(self, task: Task):\n        \"\"\"\n        Supprime les fichiers intermÃ©diaires dans le sous-dossier d'origine :\n          - flux bruts (.webm, .m4a, etc.)\n          - .fNNN.mp4 (vidÃ©o intermÃ©diaire)\n        Conserve:\n          - Titre [ID].mp4 (dÃ©jÃ  dÃ©placÃ©e)\n          - Titre [ID].mp3 (dÃ©jÃ  dÃ©placÃ©e)\n        \"\"\"\n        if not task.video_id or not task.filename:\n            return\n\n        subdir = pathlib.Path(task.filename).parent\n        if not subdir.exists():\n            return\n\n        token = f\"[{task.video_id}]\"\n        for p in list(subdir.iterdir()):\n            try:\n                if not p.is_file() or token not in p.name:\n                    continue\n                ext = p.suffix.lower()\n                # les finaux ont Ã©tÃ© dÃ©placÃ©s; on ne touche qu'aux intermÃ©diaires\n                if ext == \".mp4\":\n                    if \".f\" in p.stem:\n                        p.unlink()\n                    continue\n                if ext == \".mp3\":\n                    continue\n                p.unlink()\n            except Exception:\n                pass\n\n\nclass TikTokTab(YoutubeTab):\n    \"\"\"\n    Onglet TikTok : mÃªme logique que YoutubeTab, mais dÃ©tection d'URL TikTok,\n    format par dÃ©faut adaptÃ©, et archive dÃ©diÃ©e.\n    \"\"\"\n\n    def build_ui(self):\n        super().build_ui()\n        # Ajuster juste le placeholder dâ€™entrÃ©e pour clarifier au user\n        self.edit_url.setPlaceholderText(\"Colle une URL TikTok et presse EntrÃ©e pour lâ€™ajouter\")\n\n    # --- DÃ©tection d'URL (TikTok) ---\n    def add_url(self):\n        url = self.edit_url.text().strip()\n        if not url:\n            return\n        # DÃ©tection TikTok\n        m = TIKTOK_REGEX.search(url)\n        if not m:\n            QMessageBox.information(self, \"URL invalide\", \"Cette URL ne semble pas Ãªtre une URL TikTok.\")\n            return\n        url = m.group(1)\n        # Ã‰viter doublons\n        for i in range(self.list.count()):\n            exist_task: Task = self.list.item(i).data(Qt.UserRole)\n            if exist_task and exist_task.url == url:\n                QMessageBox.information(self, \"DÃ©jÃ  prÃ©sent\", \"Cette URL est dÃ©jÃ  dans la liste.\")\n                self.edit_url.clear()\n                return\n        item = self.append_task(url)\n        self.list.setCurrentItem(item)\n        self.inspect_task_async(item)\n        self.edit_url.clear()\n\n    def paste_clipboard(self):\n        cb = QApplication.clipboard()\n        if not cb:\n            return\n        text = (cb.text() or \"\").strip()\n        if not text:\n            return\n        match = TIKTOK_REGEX.search(text)\n        if match:\n            self.edit_url.setText(match.group(1))\n            self.add_url()\n\n    def dropEvent(self, e):\n        urls: list[str] = []\n        if e.mimeData().hasUrls():\n            for url in e.mimeData().urls():\n                path = url.toLocalFile() or url.toString()\n                if path:\n                    urls.append(path)\n        if e.mimeData().hasText():\n            urls.append(e.mimeData().text())\n        for raw in urls:\n            if not raw:\n                continue\n            match = TIKTOK_REGEX.search(raw.strip())\n            if match:\n                self.edit_url.setText(match.group(1))\n                self.add_url()\n        e.acceptProposedAction()\n\n    # --- Options yt-dlp spÃ©cifiques TikTok ---\n    def build_opts(self, task: Task):\n        outdir = OUT_DIR\n        # Sur TikTok, la vidÃ©o arrive souvent dÃ©jÃ  muxÃ©e (mp4); fallback \"best\"\n        fmt = task.selected_fmt or \"best[ext=mp4]/best\"\n\n        folder_tmpl = \"%(title).200s [%(id)s]\"\n        file_tmpl = \"%(title).200s [%(id)s].%(ext)s\"\n        outtmpl = str(outdir / folder_tmpl / file_tmpl)\n\n        opts = {\n            \"outtmpl\": outtmpl,\n            \"windowsfilenames\": True,\n            \"format\": fmt,\n            \"merge_output_format\": \"mp4\",\n            \"postprocessors\": [\n                {\"key\": \"FFmpegVideoRemuxer\", \"preferedformat\": \"mp4\"},\n                {\"key\": \"FFmpegExtractAudio\", \"preferredcodec\": \"mp3\", \"preferredquality\": \"192\"},\n            ],\n            \"keepvideo\": True,  # on garde la vidÃ©o aprÃ¨s extraction mp3\n            \"quiet\": True,\n            \"no_warnings\": True,\n            \"continuedl\": True,\n            \"concurrent_fragment_downloads\": 4,\n            \"noplaylist\": True,\n            \"download_archive\": str(DOWNLOAD_ARCHIVE_TT),  # archive sÃ©parÃ©e\n            \"nooverwrites\": True,\n            \"overwrites\": False,\n        }\n        return opts\n\n\nclass ServeurTab(QWidget):\n    \"\"\"Onglet trÃ¨s simple avec deux boutons : Allumer / Ã‰teindre.\n    Allumer => lance PowerShell avec le script (cloudflared + n8n).\n    Ã‰teindre => arrÃªte le process et son arbre.\n    \"\"\"\n\n    sig_public_url = Signal(str)\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.worker: LongProcWorker | None = None\n        self.ps_file: str | None = None\n        self._pid: int | None = None\n        self._last_public_url: str | None = None\n        self.build_ui()\n\n    def build_ui(self):\n        root = QVBoxLayout(self)\n\n        # Ligne boutons + statut\n        row = QHBoxLayout()\n        self.btn_on = QPushButton(\"Allumer\")\n        self.btn_off = QPushButton(\"Ã‰teindre\")\n        self.btn_off.setEnabled(False)\n        self.btn_open = QPushButton(\"Ouvrir n8n\")\n        self.btn_open.setEnabled(False)\n        self.lab_status = QLabel(\"Statut : inactif\")\n        self.btn_on.clicked.connect(self.start)\n        self.btn_off.clicked.connect(self.stop)\n        self.btn_open.clicked.connect(self.open_n8n)\n        row.addWidget(self.btn_on)\n        row.addWidget(self.btn_off)\n        row.addWidget(self.btn_open)\n        row.addStretch(1)\n        row.addWidget(self.lab_status)\n        root.addLayout(row)\n\n        # Logs\n        self.logs = QTextEdit()\n        self.logs.setReadOnly(True)\n        self.logs.setPlaceholderText(\"Logs cloudflared / n8nâ€¦\")\n        root.addWidget(self.logs)\n\n    # --- helpers UI ---\n    def log(self, s: str):\n        self.logs.append(s)\n        m = re.search(r\"https://[a-z0-9-]+\\.trycloudflare\\.com\", s)\n        if m:\n            url = m.group(0)\n            self._last_public_url = url\n            self.sig_public_url.emit(url)\n\n    def open_n8n(self):\n        url = self._last_public_url or \"http://localhost:5678\"\n        try:\n            QDesktopServices.openUrl(QUrl(url))\n        except Exception:\n            pass\n\n    # --- start/stop ---\n    def start(self):\n        if self.worker and self.worker.isRunning():\n            QMessageBox.information(self, \"DÃ©jÃ  en cours\", \"Le serveur est dÃ©jÃ  allumÃ©.\")\n            return\n\n        # VÃ©rifs rapides cÃ´tÃ© Python pour retour immÃ©diat Ã  l'utilisateur\n        pwsh = shutil.which(\"powershell\") or shutil.which(\"powershell.exe\")\n        if not pwsh:\n            QMessageBox.warning(self, \"PowerShell introuvable\", \"PowerShell est requis.\")\n            return\n        if not shutil.which(\"cloudflared\"):\n            QMessageBox.warning(self, \"cloudflared introuvable\",\n                                \"Installe-le : winget install Cloudflare.cloudflared\")\n            return\n        if not shutil.which(\"n8n\"):\n            QMessageBox.warning(self, \"n8n introuvable\",\n                                \"Installe-le : npm i -g n8n\")\n            return\n\n        # Ã‰crit le script PowerShell fourni par l'utilisateur dans un fichier temporaire\n        ps_code = r'''\nparam([int]$Port = 5678)\n\n$ErrorActionPreference = 'Stop'\n\n# --- VÃ©rifs rapides\nif (-not (Get-Command cloudflared -ErrorAction SilentlyContinue)) {\n  Write-Error \"cloudflared introuvable. Installe-le: winget install Cloudflare.cloudflared\"\n  exit 1\n}\nif (-not (Get-Command n8n -ErrorAction SilentlyContinue)) {\n  Write-Error \"n8n introuvable. Installe-le: npm i -g n8n\"\n  exit 1\n}\nif (Get-NetTCPConnection -State Listen -LocalPort $Port -ErrorAction SilentlyContinue) {\n  Write-Error \"Le port $Port est dÃ©jÃ  utilisÃ©. Ferme l'autre instance ou choisis un autre port.\"\n  exit 1\n}\n\n# --- 1) DÃ©marre cloudflared en arriÃ¨re-plan et loggue sa sortie (stdout/err sÃ©parÃ©s)\n$logOut = Join-Path $env:TEMP \"cloudflared_n8n_${Port}_out.log\"\n$logErr = Join-Path $env:TEMP \"cloudflared_n8n_${Port}_err.log\"\nif (Test-Path $logOut) { Remove-Item $logOut -Force }\nif (Test-Path $logErr) { Remove-Item $logErr -Force }\n\n$cfArgs = @(\"tunnel\",\"--url\",\"http://localhost:$Port\",\"--ha-connections\",\"1\",\"--protocol\",\"quic\")\n$cfProc = Start-Process (Get-Command cloudflared).Source `\n          -ArgumentList $cfArgs -NoNewWindow `\n          -RedirectStandardOutput $logOut -RedirectStandardError $logErr -PassThru\nWrite-Host \"cloudflared PID: $($cfProc.Id). Attente de l'URL publiqueâ€¦\"\n\n# --- 2) RÃ©cupÃ¨re l'URL publique\n$publicUrl = $null\n$regex = [regex]'https://[a-z0-9-]+\\.trycloudflare\\.com'\nfor ($i=0; $i -lt 60; $i++) {  # ~30s max\n  $content = \"\"\n  if (Test-Path $logOut) { $content += (Get-Content $logOut -Raw) }\n  if (Test-Path $logErr) { $content += \"`n\" + (Get-Content $logErr -Raw) }\n  if ($content) {\n    $m = $regex.Match($content)\n    if ($m.Success) { $publicUrl = $m.Value; break }\n  }\n  Start-Sleep -Milliseconds 500\n}\n\nif ($publicUrl) {\n  Write-Host \"URL publique: $publicUrl\"\n  $env:WEBHOOK_URL         = $publicUrl\n  $env:N8N_EDITOR_BASE_URL = $publicUrl\n} else {\n  Write-Warning \"Impossible de lire l'URL publique. n8n sera accessible en local uniquement.\"\n}\n\n# --- 3) Exporte le port (ne PAS changer N8N_ENCRYPTION_KEY si tu as dÃ©jÃ  lancÃ© n8n avant)\n$env:N8N_PORT = \"$Port\"\n\n# --- 4) Lance n8n au premier plan\nWrite-Host \"DÃ©marrage n8n sur http://localhost:$Port ...\"\n& (Get-Command n8n).Source\n\n# --- 5) A l'arrÃªt de n8n, coupe cloudflared proprement\nWrite-Host \"n8n arrÃªtÃ©. Extinction de cloudflaredâ€¦\"\nif ($cfProc -and -not $cfProc.HasExited) {\n  try { Stop-Process -Id $cfProc.Id -Force -ErrorAction SilentlyContinue } catch {}\n}\nWrite-Host \"TerminÃ©.\"\n'''\n        if self.ps_file and os.path.exists(self.ps_file):\n            try:\n                os.remove(self.ps_file)\n            except Exception:\n                pass\n            self.ps_file = None\n        fd, tmp = tempfile.mkstemp(prefix=\"fg_srv_\", suffix=\".ps1\")\n        os.close(fd)\n        with open(tmp, \"w\", encoding=\"utf-8\") as f:\n            f.write(ps_code)\n        self.ps_file = tmp\n\n        args = [\n            pwsh,\n            \"-NoProfile\", \"-ExecutionPolicy\", \"Bypass\",\n            \"-File\", tmp,\n            \"-Port\", \"5678\",  # le besoin: 2 boutons sans autre option; port fixe\n        ]\n\n        self.log(f\">>> Lancement serveur (port 5678)\")\n        self.lab_status.setText(\"Statut : dÃ©marrageâ€¦\")\n        self.btn_on.setEnabled(False)\n        self.btn_off.setEnabled(True)\n        self.btn_open.setEnabled(False)\n\n        self.worker = LongProcWorker(args, env=os.environ.copy(), parent=self)\n        self.worker.sig_started.connect(self.on_started)\n        self.worker.sig_line.connect(self.log)\n        self.worker.sig_done.connect(self.on_done)\n        self.worker.start()\n\n    def on_started(self, pid: int):\n        self._pid = pid\n        self.lab_status.setText(f\"Statut : en cours (pid {pid})\")\n        self.log(f\"[ps] dÃ©marrÃ© (pid {pid})\")\n        self.btn_open.setEnabled(True)\n\n    def stop(self):\n        self.lab_status.setText(\"Statut : arrÃªtâ€¦\")\n        self.log(\">>> Extinction demandÃ©eâ€¦\")\n        self.btn_open.setEnabled(False)\n        self._last_public_url = None\n        if self.worker and self.worker.isRunning():\n            self.worker.stop()\n        else:\n            self.on_done(0)\n\n    def on_done(self, code: int):\n        self.log(f\">>> TerminÃ© (code={code})\")\n        self.lab_status.setText(\"Statut : inactif\")\n        self.btn_on.setEnabled(True)\n        self.btn_off.setEnabled(False)\n        self.btn_open.setEnabled(False)\n        self._last_public_url = None\n        self._pid = None\n        self.worker = None\n        if self.ps_file:\n            try:\n                os.remove(self.ps_file)\n            except Exception:\n                pass\n            self.ps_file = None\n\n\n# ---------------------- Onglet Transcription ----------------------\nclass MultiUploadWorker(QThread):\n    sig_log = Signal(str)\n    sig_done = Signal(bool)\n\n    def __init__(self, url: str, files: List[str], parent=None):\n        super().__init__(parent)\n        self.url = url\n        self.files = list(files)\n\n    def run(self):\n        try:\n            import requests\n        except ImportError:\n            self.sig_log.emit(\"Erreur : le module 'requests' est introuvable. ExÃ©cute `pip install requests`.\")\n            self.sig_done.emit(False)\n            return\n\n        if not self.files:\n            self.sig_log.emit(\"Aucun fichier Ã  envoyer.\")\n            self.sig_done.emit(False)\n            return\n\n        all_ok = True\n        self.sig_log.emit(f\">>> Envoi vers {self.url} â€” {len(self.files)} fichier(s)\")\n        session = requests.Session()\n        for path in self.files:\n            if not os.path.exists(path):\n                self.sig_log.emit(f\"[SKIP] Introuvable : {path}\")\n                all_ok = False\n                continue\n\n            mime, _ = mimetypes.guess_type(path)\n            mime = mime or \"application/octet-stream\"\n            basename = os.path.basename(path)\n            self.sig_log.emit(\n                f\"POST {self.url}\\n  -> {basename} (MIME={mime}) field='data'\"\n            )\n\n            try:\n                with open(path, \"rb\") as handle:\n                    files = {\"data\": (basename, handle, mime)}\n                    resp = session.post(self.url, files=files, timeout=(10, 600))\n                self.sig_log.emit(f\"HTTP {resp.status_code}\")\n                body = resp.text or \"\"\n                if len(body) > 2000:\n                    body = body[:2000] + \"\\n...[tronquÃ©]...\"\n                if body.strip():\n                    self.sig_log.emit(body)\n                body_lower = body.lower()\n                if resp.status_code == 404 and (\n                    \"not registered\" in body_lower or \"did you mean get\" in body_lower\n                ):\n                    self.sig_log.emit(\n                        \"Indice : sur un webhook-test, clique sur 'Listen for test event' avant d'envoyer.\"\n                    )\n                if not (200 <= resp.status_code < 300):\n                    all_ok = False\n            except Exception as exc:\n                all_ok = False\n                self.sig_log.emit(f\"[ERREUR rÃ©seau] {exc}\")\n\n        session.close()\n        self.sig_log.emit(\">>> TerminÃ©.\")\n        self.sig_done.emit(all_ok)\n\n\nclass TranscriptionTab(QWidget):\n    sig_url_changed = Signal(str)\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.setAcceptDrops(True)\n        self.selected_paths: set[str] = set()\n        self.worker: MultiUploadWorker | None = None\n        self.last_dir: str | None = None\n        self._updating_url = False\n        self._webhook_path = \"/webhook/Audio\"\n        self.build_ui()\n        self.update_send_button()\n\n    # PATCH START: rename N8NTab -> TranscriptionTab (+ libellÃ©s)\n    def build_ui(self):\n        root = QVBoxLayout(self)\n        root.setContentsMargins(12, 12, 12, 12)\n        root.setSpacing(8)\n\n        url_row = QHBoxLayout()\n        url_row.setSpacing(8)\n        url_row.addWidget(QLabel(\"URL de transcription (n8n):\"))\n        self.edit_url = QLineEdit()\n        self.edit_url.setPlaceholderText(\"https://â€¦trycloudflare.com/webhook/Audio\")\n        self.edit_url.textChanged.connect(self.on_url_changed)\n        url_row.addWidget(self.edit_url, 1)\n        root.addLayout(url_row)\n\n        actions_row = QHBoxLayout()\n        actions_row.setSpacing(8)\n        self.btn_add = QPushButton(\"Ajouter fichier(s)â€¦\")\n        icon_add = themed_icon(\"list-add\", \"document-open\")\n        if not icon_add.isNull():\n            self.btn_add.setIcon(icon_add)\n        self.btn_add.clicked.connect(self.on_add_files)\n        self.btn_send = QPushButton()\n        icon_send = themed_icon(\"mail-send\", \"document-send\")\n        if not icon_send.isNull():\n            self.btn_send.setIcon(icon_send)\n        self.btn_send.clicked.connect(self.on_send)\n        self.btn_clear = QPushButton(\"Vider la liste\")\n        icon_clear = themed_icon(\"edit-clear\", \"user-trash\")\n        if not icon_clear.isNull():\n            self.btn_clear.setIcon(icon_clear)\n        self.btn_clear.clicked.connect(self.clear_selection_and_logs)\n        actions_row.addWidget(self.btn_add)\n        actions_row.addWidget(self.btn_send)\n        actions_row.addWidget(self.btn_clear)\n        actions_row.addStretch(1)\n        root.addLayout(actions_row)\n\n        self.list_sel = QListWidget()\n        self.list_sel.itemDoubleClicked.connect(self.remove_selected_item)\n        root.addWidget(self.list_sel, 1)\n\n        self.logs = QTextEdit()\n        self.logs.setReadOnly(True)\n        self.logs.setPlaceholderText(\"Logs webhook / rÃ©ponses serveurâ€¦\")\n        root.addWidget(self.logs, 1)\n\n        self.setMinimumSize(720, 480)\n    # PATCH END\n\n    # --- sÃ©lection ---\n    def update_send_button(self):\n        count = len(self.selected_paths)\n        self.btn_send.setText(f\"Envoyer ({count})\")\n        self.btn_send.setEnabled(count > 0 and self.worker is None)\n\n    def add_to_selection(self, path: str):\n        norm = os.path.abspath(path)\n        if norm in self.selected_paths:\n            return\n        self.selected_paths.add(norm)\n        item = QListWidgetItem(os.path.basename(norm) or norm)\n        item.setToolTip(norm)\n        item.setData(Qt.UserRole, norm)\n        self.list_sel.addItem(item)\n        self.update_send_button()\n\n    def remove_selected_item(self, item: QListWidgetItem):\n        path = item.data(Qt.UserRole)\n        if path in self.selected_paths:\n            self.selected_paths.remove(path)\n        row = self.list_sel.row(item)\n        self.list_sel.takeItem(row)\n        self.update_send_button()\n\n    def dragEnterEvent(self, e):\n        if e.mimeData().hasUrls():\n            e.acceptProposedAction()\n\n    def dropEvent(self, e):\n        if not e.mimeData().hasUrls():\n            return\n        exts = {\".mp3\", \".m4a\", \".wav\", \".aac\", \".ogg\", \".flac\", \".mp4\", \".mkv\", \".webm\"}\n        for url in e.mimeData().urls():\n            path = url.toLocalFile()\n            if path and os.path.isfile(path):\n                if os.path.splitext(path)[1].lower() in exts:\n                    self.add_to_selection(path)\n        self.update_send_button()\n        e.acceptProposedAction()\n\n    def on_add_files(self):\n        start_dir = self.last_dir or str(pathlib.Path.home())\n        files, _ = QFileDialog.getOpenFileNames(\n            self,\n            \"Choisir des fichiers\",\n            start_dir,\n            \"Audio/Video (*.mp3 *.m4a *.wav *.aac *.ogg *.flac *.mp4 *.mkv *.webm);;Tous les fichiers (*.*)\",\n        )\n        if not files:\n            return\n        for path in files:\n            self.add_to_selection(path)\n        self.last_dir = os.path.dirname(files[-1]) or self.last_dir\n\n    # --- envoi ---\n    def on_send(self):\n        if self.worker is not None:\n            QMessageBox.information(self, \"Envoi en cours\", \"Un upload est dÃ©jÃ  en cours.\")\n            return\n\n        url = (self.edit_url.text() or \"\").strip()\n        if not url:\n            QMessageBox.warning(self, \"Manque URL\", \"Colle lâ€™URL du webhook n8n.\")\n            return\n\n        if not self.selected_paths:\n            QMessageBox.information(self, \"Rien Ã  envoyer\", \"SÃ©lectionne au moins un fichier.\")\n            return\n\n        files: List[str] = []\n        for idx in range(self.list_sel.count()):\n            item = self.list_sel.item(idx)\n            path = item.data(Qt.UserRole)\n            if path:\n                files.append(path)\n\n        if not files:\n            QMessageBox.information(self, \"Rien Ã  envoyer\", \"SÃ©lectionne au moins un fichier.\")\n            return\n\n        self.btn_send.setEnabled(False)\n        self.worker = MultiUploadWorker(url, files, self)\n        self.worker.sig_log.connect(self.logs.append)\n        self.worker.sig_done.connect(self.on_sent_done)\n        self.worker.start()\n        token = os.environ.get(\"FG_NOTIFY_TOKEN\", \"change_me\")\n        self.logs.append(\"Exemple n8n â†’ App : GET http://127.0.0.1:5050/notify-done?token=<FG_NOTIFY_TOKEN>\")\n        if token == \"change_me\":\n            self.logs.append(\"DÃ©finis FG_NOTIFY_TOKEN dans tes variables dâ€™environnement pour sÃ©curiser la notification locale.\")\n\n    def on_sent_done(self, ok: bool):\n        self.worker = None\n        self.update_send_button()\n        if ok:\n            QMessageBox.information(self, \"OK\", \"Tous les envois ont rÃ©ussi.\")\n        else:\n            QMessageBox.warning(\n                self,\n                \"TerminÃ© avec erreurs\",\n                \"Au moins un fichier a Ã©chouÃ©. Consulte les logs pour les dÃ©tails.\",\n            )\n\n    def clear_selection_and_logs(self):\n        self.selected_paths.clear()\n        self.list_sel.clear()\n        self.logs.clear()\n        self.update_send_button()\n\n    # PATCH START: init + setters + envoi direct\n    def init_from_config(self, cfg: dict):\n        path = cfg.get(\"webhook_path\") or \"/webhook/Audio\"\n        full = cfg.get(\"webhook_full\") or \"\"\n        base = cfg.get(\"webhook_base\") or \"\"\n        if not full and base:\n            full = base.rstrip(\"/\") + path\n        if full:\n            self._set_url_text(full)\n        self._webhook_path = path\n\n    def set_webhook_full(self, full: str):\n        cur = (self.edit_url.text() or \"\").strip()\n        if not cur or \"trycloudflare.com\" in cur:\n            self._set_url_text(full)\n\n    def send_files_immediately(self, paths: list[str]):\n        for p in paths:\n            self.add_to_selection(p)\n        if self.worker is None:\n            self.on_send()\n        else:\n            self.logs.append(\"Upload dÃ©jÃ  en cours, les fichiers sont ajoutÃ©s Ã  la file.\")\n    # PATCH END\n\n    def _set_url_text(self, text: str):\n        self._updating_url = True\n        try:\n            self.edit_url.setText(text)\n        finally:\n            self._updating_url = False\n\n    def on_url_changed(self, text: str):\n        if self._updating_url:\n            return\n        self.sig_url_changed.emit(text)\n# ---------------------- Onglets placeholders ----------------------\nclass ComingSoonTab(QWidget):\n    def __init__(self, title=\"Ã€ venir\", parent=None):\n        super().__init__(parent)\n        lay = QVBoxLayout(self)\n        lbl = QLabel(f\"{title}\\n\\nBientÃ´t disponibleâ€¦\")\n        lbl.setAlignment(Qt.AlignCenter)\n        lay.addWidget(lbl)\n\nclass SettingsTab(QWidget):\n    \"\"\"\n    Onglet ParamÃ¨tres gÃ©nÃ©raux :\n    - ContrÃ´le du thÃ¨me\n    - Section Telegram (token, mode, dÃ©marrage)\n    - Outils de maintenance (git pull, redÃ©marrage)\n    \"\"\"\n\n    def __init__(self, app_ref=None, parent=None):\n        super().__init__(parent)\n        self.app_ref = app_ref\n        self.worker: CommandWorker | None = None\n        self._loading_cfg = False\n        self.build_ui()\n\n    def build_ui(self):\n        root = QVBoxLayout(self)\n        root.setContentsMargins(12, 12, 12, 12)\n        root.setSpacing(8)\n\n        theme_line = QHBoxLayout()\n        theme_line.setSpacing(8)\n        theme_label = QLabel(\"ThÃ¨me\")\n        self.cmb_theme = QComboBox()\n        self.cmb_theme.addItems([\"Clair\", \"Sombre\"])\n        self.cmb_theme.currentIndexChanged.connect(self.on_theme_change)\n        theme_line.addWidget(theme_label)\n        theme_line.addWidget(self.cmb_theme)\n        theme_line.addStretch(1)\n        root.addLayout(theme_line)\n        self.cmb_theme.setCurrentText(\"Sombre\")\n        theme_label.setVisible(False)\n        theme_label.setEnabled(False)\n        self.cmb_theme.setVisible(False)\n        self.cmb_theme.setEnabled(False)\n\n        # Section Telegram\n        grp_tg = QGroupBox(\"Telegram\")\n        tg_layout = QVBoxLayout(grp_tg)\n        tg_layout.setContentsMargins(12, 12, 12, 12)\n        tg_layout.setSpacing(8)\n\n        row_token = QHBoxLayout()\n        row_token.setSpacing(8)\n        row_token.addWidget(QLabel(\"Token\"))\n        self.ed_token = QLineEdit()\n        self.ed_token.setPlaceholderText(\"123456:ABC-DEFâ€¦\")\n        row_token.addWidget(self.ed_token, 1)\n        tg_layout.addLayout(row_token)\n\n        row_mode = QHBoxLayout()\n        row_mode.setSpacing(8)\n        self.lbl_mode = QLabel(\"Mode\")\n        row_mode.addWidget(self.lbl_mode)\n        self.cmb_mode = QComboBox()\n        self.cmb_mode.addItems([\"Polling\"])\n        self.cmb_mode.setCurrentText(\"Polling\")\n        row_mode.addWidget(self.cmb_mode)\n        self.lbl_port = QLabel(\"Port\")\n        row_mode.addWidget(self.lbl_port)\n        self.spin_port = QSpinBox()\n        self.spin_port.setRange(1, 65535)\n        self.spin_port.setValue(8081)\n        row_mode.addWidget(self.spin_port)\n        row_mode.addStretch(1)\n        tg_layout.addLayout(row_mode)\n\n        self.lbl_mode.setVisible(False)\n        self.lbl_mode.setEnabled(False)\n        self.cmb_mode.setVisible(False)\n        self.cmb_mode.setEnabled(False)\n        self.lbl_port.setVisible(False)\n        self.lbl_port.setEnabled(False)\n        self.spin_port.setVisible(False)\n        self.spin_port.setEnabled(False)\n\n        row_browser = QHBoxLayout()\n        row_browser.setSpacing(8)\n        self.lbl_browser_cookies = QLabel(\"Source cookies\")\n        row_browser.addWidget(self.lbl_browser_cookies)\n        self.cmb_browser_cookies = QComboBox()\n        self._browser_combo_values: list[tuple[str, str]] = [\n            (\"Auto (fallback)\", \"auto\"),\n            (\"Edge\", \"edge\"),\n            (\"Chrome\", \"chrome\"),\n            (\"Firefox\", \"firefox\"),\n            (\"Brave\", \"brave\"),\n            (\"Vivaldi\", \"vivaldi\"),\n            (\"Opera\", \"opera\"),\n            (\"Chromium\", \"chromium\"),\n            (\"cookies.txt\", \"cookiefile\"),\n            (\"Aucun (sans cookies)\", \"none\"),\n        ]\n        for label, value in self._browser_combo_values:\n            self.cmb_browser_cookies.addItem(label, value)\n        row_browser.addWidget(self.cmb_browser_cookies, 1)\n        row_browser.addStretch(1)\n        tg_layout.addLayout(row_browser)\n\n        row_cookies = QHBoxLayout()\n        row_cookies.setSpacing(8)\n        self.lbl_cookies = QLabel(\"Cookies.txt\")\n        row_cookies.addWidget(self.lbl_cookies)\n        self.ed_cookies = QLineEdit()\n        self.ed_cookies.setPlaceholderText(\"Chemin vers cookies.txt (optionnel)\")\n        row_cookies.addWidget(self.ed_cookies, 1)\n        self.btn_cookies = QPushButton(\"Parcourirâ€¦\")\n        icon_file = themed_icon(\"document-open\", \"folder-open\")\n        if not icon_file.isNull():\n            self.btn_cookies.setIcon(icon_file)\n        self.btn_cookies.clicked.connect(self.on_pick_cookies)\n        row_cookies.addWidget(self.btn_cookies)\n        tg_layout.addLayout(row_cookies)\n\n        row_user_agent = QHBoxLayout()\n        row_user_agent.setSpacing(8)\n        self.lbl_user_agent = QLabel(\"User-Agent\")\n        row_user_agent.addWidget(self.lbl_user_agent)\n        self.ed_user_agent = QLineEdit()\n        self.ed_user_agent.setPlaceholderText(\"Mozilla/5.0 â€¦\")\n        row_user_agent.addWidget(self.ed_user_agent, 1)\n        tg_layout.addLayout(row_user_agent)\n\n        row_ctrl = QHBoxLayout()\n        row_ctrl.setSpacing(8)\n        self.btn_tg_start = QPushButton(\"DÃ©marrer bot\")\n        icon_start = themed_icon(\"media-playback-start\", \"system-run\")\n        if not icon_start.isNull():\n            self.btn_tg_start.setIcon(icon_start)\n        self.btn_tg_stop = QPushButton(\"ArrÃªter bot\")\n        icon_stop = themed_icon(\"media-playback-stop\", \"process-stop\")\n        if not icon_stop.isNull():\n            self.btn_tg_stop.setIcon(icon_stop)\n        self.btn_tg_stop.setEnabled(False)\n        self.lab_tg = QLabel(\"Bot : inactif\")\n        row_ctrl.addWidget(self.btn_tg_start)\n        row_ctrl.addWidget(self.btn_tg_stop)\n        row_ctrl.addStretch(1)\n        row_ctrl.addWidget(self.lab_tg)\n        tg_layout.addLayout(row_ctrl)\n\n        root.addWidget(grp_tg)\n\n        # Ligne boutons maintenance\n        line = QHBoxLayout()\n        line.setSpacing(8)\n        self.btn_update = QPushButton(\"Mettre Ã  jour lâ€™app (redÃ©marrage auto)\")\n        icon_update = themed_icon(\"view-refresh\", \"system-software-update\")\n        if not icon_update.isNull():\n            self.btn_update.setIcon(icon_update)\n        self.btn_restart = QPushButton(\"RedÃ©marrer lâ€™app\")\n        icon_restart = themed_icon(\"system-reboot\", \"application-exit\")\n        if not icon_restart.isNull():\n            self.btn_restart.setIcon(icon_restart)\n        self.btn_update.clicked.connect(self.on_update_clicked)\n        self.btn_restart.clicked.connect(self.on_restart_clicked)\n        line.addWidget(self.btn_update)\n        line.addWidget(self.btn_restart)\n        root.addLayout(line)\n\n        self.lab_git_hint = QLabel(\"\")\n        self.lab_git_hint.setWordWrap(True)\n        root.addWidget(self.lab_git_hint)\n\n        git_grp = QGroupBox(\"Git â€“ Outils de merge\")\n        self.git_grp = git_grp\n        git_layout = QHBoxLayout(git_grp)\n        git_layout.setContentsMargins(12, 12, 12, 12)\n        git_layout.setSpacing(8)\n        self.btn_git_continue = QPushButton(\"Continuer le merge (guidÃ©)\")\n        self.btn_git_continue.clicked.connect(self.on_git_continue_merge)\n        self.btn_git_abort = QPushButton(\"Abort merge (git merge --abort)\")\n        self.btn_git_abort.clicked.connect(self.on_git_merge_abort)\n        self.btn_git_stash_pull = QPushButton(\"Stash & Pull (rebase)\")\n        self.btn_git_stash_pull.clicked.connect(self.on_git_stash_pull)\n        git_layout.addWidget(self.btn_git_continue)\n        git_layout.addWidget(self.btn_git_abort)\n        git_layout.addWidget(self.btn_git_stash_pull)\n        root.addWidget(git_grp)\n        self.git_grp.setVisible(False)\n\n        # Zone de logs\n        self.logs = QTextEdit()\n        self.logs.setReadOnly(True)\n        self.logs.setPlaceholderText(\"Logs des opÃ©rations (git, Telegram, etc.)...\")\n        root.addWidget(self.logs)\n\n        # Info\n        info = QLabel(\"Astuce : lâ€™app cherchera la racine du dÃ©pÃ´t (.git) en remontant depuis le dossier du script.\")\n        info.setWordWrap(True)\n        root.addWidget(info)\n\n        # Connexions config Telegram / yt-dlp\n        self.ed_token.textChanged.connect(lambda s: self._save_cfg(\"telegram_token\", s.strip()))\n        self.cmb_mode.currentTextChanged.connect(lambda t: self._save_cfg(\"telegram_mode\", (t or \"auto\").lower()))\n        self.spin_port.valueChanged.connect(lambda v: self._save_cfg(\"telegram_port\", int(v)))\n        self.ed_cookies.textChanged.connect(lambda s: self._save_cfg(\"cookies_path\", s.strip()))\n        self.ed_user_agent.textChanged.connect(lambda s: self._save_cfg(\"user_agent\", s.strip()))\n        self.cmb_browser_cookies.currentIndexChanged.connect(self.on_browser_choice_changed)\n\n        self._update_cookie_inputs_state(\"auto\")\n        self.refresh_merge_state()\n\n    def init_from_config(self, cfg: dict):\n        self._loading_cfg = True\n        try:\n            token = cfg.get(\"telegram_token\") or \"\"\n            self.ed_token.setText(token)\n            self.cmb_mode.setCurrentText(\"Polling\")\n            port = int(cfg.get(\"telegram_port\") or DEFAULT_CONFIG[\"telegram_port\"])\n            self.spin_port.setValue(port)\n            cookies_path = cfg.get(\"cookies_path\") or \"\"\n            self.ed_cookies.setText(cookies_path)\n            user_agent = cfg.get(\"user_agent\") or DEFAULT_CONFIG[\"user_agent\"]\n            self.ed_user_agent.setText(user_agent)\n            browser_pref = (cfg.get(\"browser_cookies\") or \"auto\").strip().lower()\n            idx = self.cmb_browser_cookies.findData(browser_pref)\n            if idx < 0:\n                idx = 0\n            self.cmb_browser_cookies.setCurrentIndex(idx)\n            current_mode = self.cmb_browser_cookies.currentData(Qt.UserRole) or \"auto\"\n            self._update_cookie_inputs_state(str(current_mode))\n            self.set_telegram_idle()\n        finally:\n            self._loading_cfg = False\n        self.refresh_merge_state()\n\n    def _save_cfg(self, key: str, value: Any):\n        if self._loading_cfg or not self.app_ref:\n            return\n        cfg = self.app_ref.app_config\n        if key == \"telegram_token\":\n            cfg[key] = value or \"\"\n        elif key == \"telegram_mode\":\n            cfg[key] = value or \"polling\"\n        elif key == \"telegram_port\":\n            cfg[key] = int(value)\n        elif key == \"cookies_path\":\n            cfg[key] = value or \"\"\n        elif key == \"user_agent\":\n            cfg[key] = value or \"\"\n        elif key == \"browser_cookies\":\n            cfg[key] = value or \"auto\"\n        else:\n            cfg[key] = value\n        save_config(cfg)\n\n    def on_browser_choice_changed(self):\n        mode = self.cmb_browser_cookies.currentData(Qt.UserRole) or \"auto\"\n        self._update_cookie_inputs_state(str(mode))\n        if self._loading_cfg:\n            return\n        self._save_cfg(\"browser_cookies\", str(mode))\n\n    def _update_cookie_inputs_state(self, mode: str) -> None:\n        enable_cookie_file = mode == \"cookiefile\"\n        for widget in (self.lbl_cookies, self.ed_cookies, self.btn_cookies):\n            widget.setEnabled(enable_cookie_file)\n        # garder les champs visibles mais verrouillÃ©s si non pertinents\n        self.ed_cookies.setReadOnly(not enable_cookie_file)\n\n    def set_telegram_running(self, mode: str):\n        self.lab_tg.setText(f\"Bot : en cours ({mode})\")\n        self.btn_tg_start.setEnabled(False)\n        self.btn_tg_stop.setEnabled(True)\n\n    def set_telegram_idle(self):\n        self.lab_tg.setText(\"Bot : inactif\")\n        self.btn_tg_start.setEnabled(True)\n        self.btn_tg_stop.setEnabled(False)\n\n    def append_telegram_info(self, text: str):\n        self.append_log(f\"[Telegram] {text}\")\n\n    def on_pick_cookies(self):\n        path, _ = QFileDialog.getOpenFileName(self, \"Cookies.txt\", \"\", \"Text (*.txt);;Tous les fichiers (*.*)\")\n        if path:\n            self.ed_cookies.setText(path)\n\n    def refresh_merge_state(self):\n        repo = self.find_git_root()\n        in_merge = bool(repo and _is_merge_in_progress(repo))\n        if in_merge:\n            self.lab_git_hint.setText(\"Merge en cours dÃ©tectÃ©. Utilise les outils ci-dessous pour le rÃ©soudre.\")\n            self.btn_update.setEnabled(False)\n        else:\n            self.lab_git_hint.setText(\"\")\n            if not (self.worker and self.worker.isRunning()):\n                self.btn_update.setEnabled(True)\n\n    def _launch_git(self, args: list[str], cwd: pathlib.Path, next_cb: Callable[[int], None] | None = None) -> bool:\n        if self.worker and self.worker.isRunning():\n            QMessageBox.information(self, \"Git\", \"Une commande git est dÃ©jÃ  en cours.\")\n            return False\n        git = shutil.which(\"git\")\n        if not git:\n            QMessageBox.warning(self, \"Git\", \"Git introuvable dans le PATH.\")\n            return False\n        self.append_log(f\">>> git {' '.join(args)}\")\n        self.btn_update.setEnabled(False)\n        worker = CommandWorker([git, *args], cwd=cwd)\n        self.worker = worker\n        worker.sig_line.connect(self.append_log)\n\n        def done(code: int):\n            self.append_log(f\">>> (exit={code})\")\n            self.worker = None\n            if next_cb:\n                next_cb(code)\n            else:\n                self.refresh_merge_state()\n\n        worker.sig_done.connect(done)\n        worker.start()\n        return True\n\n    def _run_git_sequence(self, commands: list[list[str]], cwd: pathlib.Path):\n        if not commands:\n            self.refresh_merge_state()\n            return\n\n        first, *rest = commands\n\n        def after(code: int):\n            if code == 0 and rest:\n                self._run_git_sequence(rest, cwd)\n            else:\n                self.refresh_merge_state()\n\n        if not self._launch_git(first, cwd, next_cb=after):\n            self.refresh_merge_state()\n\n    def on_git_merge_abort(self):\n        repo = self.find_git_root()\n        if not repo:\n            self.append_log(\"Pas de repo.\")\n            return\n        if not _is_merge_in_progress(repo):\n            QMessageBox.information(self, \"Git\", \"Aucun merge en cours.\")\n            return\n        self.append_log(f\">>> cwd: {repo}\")\n        self._launch_git([\"merge\", \"--abort\"], repo)\n\n    def on_git_continue_merge(self):\n        repo = self.find_git_root()\n        if not repo:\n            self.append_log(\"Pas de repo.\")\n            return\n        if not _is_merge_in_progress(repo):\n            QMessageBox.information(self, \"Git\", \"Aucun merge en cours.\")\n            return\n        self.append_log(f\">>> cwd: {repo}\")\n        if self._launch_git([\"status\"], repo):\n            self.append_log(\"Conseil: rÃ©sous les conflits, puis `git add -A` et `git commit`.\\nUtilise 'Mettre Ã  jour' ensuite.\")\n\n    def on_git_stash_pull(self):\n        repo = self.find_git_root()\n        if not repo:\n            self.append_log(\"Pas de repo.\")\n            return\n        self.append_log(f\">>> cwd: {repo}\")\n        cmds = [\n            [\"stash\", \"push\", \"-u\", \"-m\", \"flowgrab-auto\"],\n            [\"pull\", \"--rebase\", \"origin\", \"main\"],\n            [\"stash\", \"pop\"],\n        ]\n        self._run_git_sequence(cmds, repo)\n\n    # ---------- Actions ----------\n    def on_theme_change(self, _idx: int):\n        app = QApplication.instance()\n        if not app:\n            return\n        apply_dark_theme(app)\n        if self.cmb_theme.currentText() != \"Sombre\":\n            self.cmb_theme.blockSignals(True)\n            self.cmb_theme.setCurrentText(\"Sombre\")\n            self.cmb_theme.blockSignals(False)\n\n    def on_update_clicked(self):\n        import os, sys, subprocess, pathlib\n\n        repo_root = self.find_git_root()\n        if not repo_root:\n            QMessageBox.warning(self, \"Hors dÃ©pÃ´t Git\", \"Aucun dossier '.git' trouvÃ© en remontant depuis ce projet.\")\n            return\n\n        # Si un merge est en cours, on ne tente pas un pull auto\n        if _is_merge_in_progress(repo_root):\n            QMessageBox.information(self, \"Git\", \"Un merge est en cours. RÃ©sous-le avant de mettre Ã  jour.\")\n            self.refresh_merge_state()\n            return\n\n        # Localise lâ€™updater\n        updater_py = pathlib.Path(__file__).resolve().parent / \"scripts\" / \"updater.py\"\n        if not updater_py.exists():\n            QMessageBox.warning(self, \"Updater manquant\", f\"Fichier introuvable : {updater_py}\")\n            return\n\n        python_exe = sys.executable\n        main_script = os.path.abspath(sys.argv[0])\n\n        # Message utilisateur\n        QMessageBox.information(\n            self,\n            \"Mise Ã  jour\",\n            \"Lâ€™application va se fermer, appliquer la mise Ã  jour (git pull) puis redÃ©marrer automatiquement.\"\n        )\n\n        try:\n            subprocess.Popen(\n                [python_exe, \"-u\", str(updater_py), str(repo_root), python_exe, main_script],\n                close_fds=True\n            )\n        except Exception as e:\n            QMessageBox.warning(self, \"Erreur\", f\"Impossible de lancer lâ€™updater : {e}\")\n            return\n\n        # Ferme l'app courante pour libÃ©rer les fichiers avant le pull\n        app = QApplication.instance()\n        if app:\n            app.quit()\n\n    def on_update_done(self, code: int):\n        if code != 0:\n            QMessageBox.warning(\n                self,\n                \"Ã‰chec mise Ã  jour\",\n                \"La commande git s'est terminÃ©e avec une erreur.\\nConsulte les logs.\",\n            )\n        else:\n            QMessageBox.information(\n                self,\n                \"Mise Ã  jour OK\",\n                \"Pull terminÃ©. Clique sur 'RedÃ©marrer lâ€™app' pour prendre en compte les changements.\",\n            )\n\n    def on_restart_clicked(self):\n        # Relance le mÃªme script avec les mÃªmes arguments\n        try:\n            subprocess.Popen([sys.executable, *sys.argv], close_fds=True)\n        except Exception as e:\n            QMessageBox.warning(self, \"Erreur\", f\"Impossible de redÃ©marrer : {e}\")\n            return\n        QApplication.instance().quit()\n\n    # ---------- Utils ----------\n    def append_log(self, text: str):\n        self.logs.append(text)\n\n    def find_git_root(self) -> Optional[pathlib.Path]:\n        \"\"\"\n        Remonte depuis le dossier du script pour trouver un rÃ©pertoire contenant '.git'.\n        \"\"\"\n        p = pathlib.Path(__file__).resolve().parent\n        for parent in [p, *p.parents]:\n            if (parent / \".git\").exists():\n                return parent\n        # dernier essai : si on exÃ©cute depuis un dossier qui a .git\n        if (pathlib.Path.cwd() / \".git\").exists():\n            return pathlib.Path.cwd()\n        return None\n\n# ---------------------- FenÃªtre principale ----------------------\nclass Main(QWidget):\n    def __init__(self):\n        super().__init__()\n\n        def _is_elevated_win() -> bool:\n            if not sys.platform.startswith(\"win\"):\n                return False\n            try:\n                import ctypes\n\n                return bool(ctypes.windll.shell32.IsUserAnAdmin())  # type: ignore[attr-defined]\n            except Exception:\n                return False\n\n        if _is_elevated_win():\n            QMessageBox.information(\n                self,\n                \"Conseil\",\n                \"Lâ€™application tourne en mode administrateur. Si les cookies Chromium ne se dÃ©chiffrent pas (DPAPI), \"\n                \"relance lâ€™app sans Ã©lÃ©vation ou force 'browser_cookies' = 'firefox' dans flowgrab_config.json.\",\n            )\n        self.setWindowTitle(\"FlowGrab â€” Video Downloader (yt-dlp)\")\n        root = QVBoxLayout(self)\n        # PATCH START: tabs wiring + config + signaux\n        self.app_config = load_config()\n        self.telegram_worker: TelegramWorker | None = None\n\n        self.youtube_tab = YoutubeTab(app_ref=QApplication.instance())\n        self.tiktok_tab = TikTokTab(app_ref=QApplication.instance())\n        self.transcription_tab = TranscriptionTab()\n        self.serveur_tab = ServeurTab()\n        self.settings_tab = SettingsTab(app_ref=self)\n\n        tabs = QTabWidget()\n        tabs.addTab(self.youtube_tab, \"YouTube\")\n        tabs.addTab(self.tiktok_tab, \"TikTok\")\n        tabs.addTab(self.transcription_tab, \"Transcription\")\n        tabs.addTab(ComingSoonTab(\"Ã€ venir 3\"), \"Ã€ venir 3\")\n        tabs.addTab(ComingSoonTab(\"Ã€ venir 4\"), \"Ã€ venir 4\")\n        tabs.addTab(self.settings_tab, \"ParamÃ¨tres gÃ©nÃ©raux\")\n        tabs.addTab(self.serveur_tab, \"Serveur\")\n        self.tabs = tabs\n        root.addWidget(tabs)\n\n        # Config JSON\n        self.transcription_tab.init_from_config(self.app_config)\n        self.settings_tab.init_from_config(self.app_config)\n\n        # Signaux inter-onglets\n        self.serveur_tab.sig_public_url.connect(self.on_cloudflare_public_url)       # base\n        self.youtube_tab.sig_request_transcription.connect(self.on_transcription_request)\n        self.youtube_tab.sig_audio_completed.connect(self.on_audio_ready_from_youtube)\n        self.tiktok_tab.sig_request_transcription.connect(self.on_transcription_request)\n        self.tiktok_tab.sig_audio_completed.connect(self.on_audio_ready_from_youtube)\n        self.transcription_tab.sig_url_changed.connect(self.on_transcription_url_changed)\n\n        # ParamÃ¨tres Telegram\n        self.settings_tab.btn_tg_start.clicked.connect(self.start_telegram)\n        self.settings_tab.btn_tg_stop.clicked.connect(self.stop_telegram)\n        # PATCH END\n\n        start_notification_server(self)\n\n    # PATCH START: slots Main pour webhook et transcription\n    def on_cloudflare_public_url(self, base: str):\n        path = self.app_config.get(\"webhook_path\") or \"/webhook/Audio\"\n        if not path.startswith(\"/\"):\n            path = \"/\" + path\n        full = base.rstrip(\"/\") + path\n        self.app_config.update({\"webhook_base\": base, \"webhook_full\": full, \"webhook_path\": path})\n        save_config(self.app_config)\n        self.transcription_tab.set_webhook_full(full)\n\n    def on_transcription_request(self, file_paths: list[str]):\n        self.tabs.setCurrentWidget(self.transcription_tab)\n        self.transcription_tab.send_files_immediately(file_paths)\n\n    def on_transcription_url_changed(self, text: str):\n        path = getattr(self.transcription_tab, \"_webhook_path\", \"/webhook/Audio\") or \"/webhook/Audio\"\n        text = (text or \"\").strip()\n        if path and not path.startswith(\"/\"):\n            path = \"/\" + path\n        base = \"\"\n        if text and path and path in text:\n            idx = text.rfind(path)\n            if idx >= 0:\n                base = text[:idx]\n        if not base:\n            base = text.rstrip(\"/\")\n        self.app_config.update({\n            \"webhook_base\": base.rstrip(\"/\"),\n            \"webhook_full\": text,\n            \"webhook_path\": path,\n        })\n        save_config(self.app_config)\n    # PATCH END\n\n    # PATCH START: Telegram intÃ©gration\n    def _effective_telegram_mode(self) -> str:\n        return \"polling\"\n\n    def start_telegram(self):\n        token = (self.app_config.get(\"telegram_token\") or \"\").strip()\n        if not token:\n            QMessageBox.warning(self, \"Token manquant\", \"Renseigne le token du bot Telegram dans les paramÃ¨tres.\")\n            return\n        if self.telegram_worker and self.telegram_worker.isRunning():\n            QMessageBox.information(self, \"Bot actif\", \"Le bot Telegram est dÃ©jÃ  dÃ©marrÃ©.\")\n            return\n        worker = TelegramWorker(self.app_config)\n        self.telegram_worker = worker\n        worker.sig_download_requested.connect(self.on_tg_download_requested)\n        worker.sig_info.connect(self.on_telegram_info)\n        worker.finished.connect(self.on_telegram_finished)\n        mode = worker.effective_mode or self._effective_telegram_mode()\n        if self.settings_tab:\n            self.settings_tab.set_telegram_running(mode)\n            self.settings_tab.append_telegram_info(f\"DÃ©marrage bot ({mode})\")\n        worker.start()\n\n    def stop_telegram(self):\n        if not self.telegram_worker:\n            if self.settings_tab:\n                self.settings_tab.set_telegram_idle()\n            return\n        worker = self.telegram_worker\n        if self.settings_tab:\n            self.settings_tab.append_telegram_info(\"ArrÃªt du bot demandÃ©â€¦\")\n        worker.stop()\n        worker.wait(5000)\n        self.telegram_worker = None\n        if self.settings_tab:\n            self.settings_tab.set_telegram_idle()\n\n    def on_telegram_finished(self):\n        if self.settings_tab:\n            self.settings_tab.set_telegram_idle()\n        if self.telegram_worker and not self.telegram_worker.isRunning():\n            self.telegram_worker = None\n\n    def on_telegram_info(self, text: str):\n        if self.settings_tab:\n            self.settings_tab.append_telegram_info(text)\n\n    def on_tg_download_requested(self, url: str, fmt: str, chat_id: int | str, title: str):\n        try:\n            chat_ref: int | str = int(chat_id)\n        except (TypeError, ValueError):\n            chat_ref = chat_id\n        item = self.youtube_tab.append_task(url)\n        task: Task = item.data(Qt.UserRole)\n        task.selected_fmt = fmt\n        task.source = \"telegram\"\n        task.chat_id = chat_ref\n        self.youtube_tab.statusBar(f\"TÃ©lÃ©chargement demandÃ© par Telegram â€” {title}\")\n        self.youtube_tab.start_queue()\n        if self.telegram_worker:\n            self.telegram_worker.send_message(chat_ref, \"TÃ©lÃ©chargement lancÃ©â€¦\")\n\n    def on_audio_ready_from_youtube(self, chat_id: int | str, audio_path: str):\n        if not self.telegram_worker:\n            return\n        try:\n            chat_ref: int | str = int(chat_id)\n        except (TypeError, ValueError):\n            chat_ref = chat_id\n        name = os.path.basename(audio_path) or audio_path\n        self.telegram_worker.send_message(chat_ref, f\"TÃ©lÃ©chargement terminÃ© âœ…\\n{name}\")\n        self.telegram_worker.ask_transcription(chat_ref, audio_path)\n    # PATCH END\n\n    def closeEvent(self, event):\n        try:\n            self.stop_telegram()\n        finally:\n            super().closeEvent(event)\n\n# ---------------------- main ----------------------\nif __name__ == \"__main__\":\n    app = QApplication(sys.argv)\n    apply_dark_theme(app)\n    w = Main()\n    w.show()\n    sys.exit(app.exec())\n",
  "requirements.txt": "python-telegram-bot>=21,<22\n",
  "scripts/updater.py": "import sys, subprocess, time, os, shutil, pathlib\n\n\ndef main():\n    if len(sys.argv) < 4:\n        print(\"Usage: updater.py <repo_root> <python_exe> <main_script>\")\n        return 2\n\n    repo_root   = pathlib.Path(sys.argv[1])\n    python_exe  = sys.argv[2]\n    main_script = os.path.abspath(sys.argv[3])\n\n    # Laisse le temps au process principal de se fermer et libÃ©rer les fichiers\n    time.sleep(1.2)\n\n    # Quelques tentatives pour s'assurer que le script principal n'est plus verrouillÃ©\n    for _ in range(5):\n        try:\n            with open(main_script, \"rb\"):\n                pass\n            break\n        except Exception:\n            time.sleep(0.6)\n\n    git = shutil.which(\"git\")\n    ret = 0\n    if not git:\n        print(\"Git introuvable dans le PATH.\")\n        ret = 1\n    else:\n        print(f\"[Updater] git pull origin main â€” cwd={repo_root}\")\n        proc = subprocess.run([git, \"pull\", \"origin\", \"main\"], cwd=str(repo_root), text=True)\n        ret = proc.returncode or 0\n        print(f\"[Updater] git pull terminÃ© (exit={ret})\")\n\n    # Relance lâ€™application quoi quâ€™il arrive (mÃªme si la mise Ã  jour Ã©choue)\n    try:\n        subprocess.Popen([python_exe, main_script], close_fds=True)\n        print(\"[Updater] Application relancÃ©e.\")\n    except Exception as e:\n        print(f\"[Updater] Relance impossible : {e}\")\n        return 3\n\n    return ret\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n"
}