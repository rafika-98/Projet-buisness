{
  ".gitignore": "# Sorties & médias\ndownloads/\nVideos/\nAudios/\n*.mp4\n*.mkv\n*.webm\n*.mp3\n*.m4a\n\n# Python cache\n__pycache__/\n*.pyc\n\n# Secrets & config locale\n.env\nflowgrab_config.json\n",
  "README.md": "# Projet-buisness\r\n",
  "flowgrab_tabs.py": "import os, subprocess, shutil, sys, pathlib, mimetypes\nimport signal\nimport tempfile\nimport threading\nimport asyncio\nimport secrets\nimport re\nimport time\nimport random\n\nOUT_DIR = pathlib.Path(r\"C:\\Users\\Lamine\\Desktop\\Projet final\\Application\\downloads\")\nOUT_DIR.mkdir(parents=True, exist_ok=True)\nVIDEOS_DIR = OUT_DIR / \"Videos\"\nAUDIOS_DIR = OUT_DIR / \"Audios\"\nTRANSCRIPTION_DIR = OUT_DIR / \"Transcription\"\nVIDEOS_DIR.mkdir(parents=True, exist_ok=True)\nAUDIOS_DIR.mkdir(parents=True, exist_ok=True)\nTRANSCRIPTION_DIR.mkdir(parents=True, exist_ok=True)\nDOWNLOAD_ARCHIVE = OUT_DIR / \"archive.txt\"\nDOWNLOAD_ARCHIVE_TT = OUT_DIR / \"archive_tiktok.txt\"\n\nfrom typing import Optional, List, Dict, Any, TYPE_CHECKING, Callable, Tuple\n\nif TYPE_CHECKING:  # pragma: no cover - typing uniquement\n    from telegram.ext import Application\n\nimport telegram as tg  # pour la version\n\nYOUTUBE_REGEX = re.compile(\n    r\"(https?://(?:www\\.)?(?:youtube\\.com/watch\\?\\S*?v=[^\\s&]+|youtu\\.be/[^\\s/?#]+)[^\\s]*)\",\n    re.IGNORECASE,\n)\n\nTIKTOK_REGEX = re.compile(\n    r\"(https?://(?:www\\.)?(?:tiktok\\.com/.+?/video/\\d+|vt\\.tiktok\\.com/\\S+|vm\\.tiktok\\.com/\\S+))\",\n    re.IGNORECASE,\n)\n\nBROWSER_TRY_ORDER = (\"edge\", \"chrome\", \"brave\", \"vivaldi\", \"opera\", \"chromium\", \"firefox\")\n\n\nclass YtdlpLogger:\n    def __init__(self, emit: Callable[[str], None]):\n        self.emit = emit\n\n    def debug(self, msg: str) -> None:  # pragma: no cover - silencieux par défaut\n        # ignorer le bruit debug de yt-dlp pour garder la console propre\n        return\n\n    def warning(self, msg: str) -> None:\n        try:\n            self.emit(f\"[yt-dlp] {msg}\")\n        except Exception:\n            pass\n\n    def error(self, msg: str) -> None:\n        try:\n            self.emit(f\"[yt-dlp] {msg}\")\n        except Exception:\n            pass\n\n\ndef _apply_cookies_to_opts(opts: dict, cfg: dict) -> None:\n    \"\"\"Prépare les options yt-dlp selon la config courante.\"\"\"\n\n    mode = (cfg.get(\"browser_cookies\") or \"auto\").strip().lower()\n    cookies = (cfg.get(\"cookies_path\") or \"\").strip()\n\n    opts.pop(\"cookiefile\", None)\n    opts.pop(\"cookiesfrombrowser\", None)\n\n    if mode == \"none\":\n        return\n\n    if mode == \"cookiefile\":\n        if cookies:\n            opts[\"cookiefile\"] = cookies\n        return\n\n    if mode in BROWSER_TRY_ORDER:\n        opts[\"cookiesfrombrowser\"] = (mode, None, None, None)\n        return\n\n    # mode auto : utiliser le premier navigateur de la liste, le reste sera géré via fallback\n    order = _browser_fallback_order(cfg)\n    browser = order[0] if order else BROWSER_TRY_ORDER[0]\n    opts[\"cookiesfrombrowser\"] = (browser, None, None, None)\n\n\ndef _is_dpapi_error(exc: Exception) -> bool:\n    msg = (str(exc) or \"\").lower()\n    needles = (\"dpapi\", \"decrypt\", \"encrypted_key\", \"os_crypt\", \"failed to decrypt\")\n    return any(k in msg for k in needles)\n\n\ndef _is_chrome_copy_error(exc: Exception) -> bool:\n    msg = (str(exc) or \"\").lower()\n    if not msg:\n        return False\n    return (\"could not copy\" in msg and \"cookie\" in msg and \"database\" in msg) or (\n        \"could not copy chrome cookie database\" in msg\n    )\n\n\ndef _browser_fallback_order(cfg: dict) -> list[str]:\n    pref = (cfg.get(\"browser_cookies\") or \"auto\").strip().lower()\n    if pref in BROWSER_TRY_ORDER:\n        return [pref]\n    if pref == \"auto\":\n        return list(BROWSER_TRY_ORDER)\n    return []\n\n\ndef _ptb_major_minor() -> tuple[int, int]:\n    try:\n        parts = tg.__version__.split(\".\")[:2]\n        return int(parts[0]), int(parts[1])\n    except Exception:\n        return 20, 0\n\n\ndef _backoff_sleep(attempt: int, base: float = 1.5, jitter: bool = True) -> None:\n    delay = base ** attempt\n    if jitter:\n        delay += random.uniform(0, 0.5)\n    time.sleep(delay)\n\n\ndef normalize_yt(u: str) -> str:\n    \"\"\"\n    Normalise une URL YouTube :\n    - supprime le paramètre ?si=... (inutile pour yt-dlp)\n    - convertit youtu.be/<id> en https://www.youtube.com/watch?v=<id>\n    \"\"\"\n    try:\n        if not u:\n            return u\n        # retire ?si=... ou &si=...\n        u = re.sub(r'([?&])si=[^&]+&?', r'\\1', u)\n        u = re.sub(r'[?&]$', '', u)\n\n        m = re.search(r'youtu\\.be/([A-Za-z0-9_-]{6,})', u)\n        if m:\n            vid = m.group(1)\n            return f\"https://www.youtube.com/watch?v={vid}\"\n        return u\n    except Exception:\n        return u\n\n\ndef normalize_tiktok(u: str) -> str:\n    \"\"\"\n    Normalise une URL TikTok :\n    - supprime certains paramètres marketing courants\n    - laisse les liens courts (vm./vt.) tels quels (yt-dlp gère la redirection)\n    \"\"\"\n    try:\n        if not u:\n            return u\n        # retire paramètres bruyants (_r, _t, share_link_id, etc.)\n        u = re.sub(r'([?&])(?:_r|_t|share_link_id|sender_device)=\\w+&?', r'\\1', u)\n        u = re.sub(r'[?&]$', '', u)\n        return u\n    except Exception:\n        return u\n\n\ndef normalize_url(u: str) -> str:\n    if not u:\n        return u\n    low = u.lower()\n    if \"youtu\" in low:\n        return normalize_yt(u)\n    if \"tiktok.com\" in low or \"vm.tiktok.com\" in low or \"vt.tiktok.com\" in low:\n        return normalize_tiktok(u)\n    return u\n\n\ndef _is_path_in_dir(candidate: pathlib.Path, directory: pathlib.Path) -> bool:\n    try:\n        candidate.relative_to(directory)\n        return True\n    except ValueError:\n        return False\n\n\ndef extract_basic_info(url: str) -> dict:\n    \"\"\"Récupère les métadonnées d'une vidéo sans lancer de téléchargement.\"\"\"\n    u = normalize_url(url)\n    cfg = load_config()\n    user_agent = (cfg.get(\"user_agent\") or DEFAULT_CONFIG[\"user_agent\"]).strip()\n    base_opts: dict[str, Any] = {\n        \"quiet\": True,\n        \"no_warnings\": True,\n        \"retries\": 2,\n        \"socket_timeout\": 15,\n        \"logger\": YtdlpLogger(lambda _: None),\n    }\n    if user_agent:\n        base_opts[\"http_headers\"] = {\"User-Agent\": user_agent}\n\n    cookies_path = (cfg.get(\"cookies_path\") or \"\").strip()\n    browser_pref = (cfg.get(\"browser_cookies\") or \"auto\").strip().lower()\n\n    def _extract(local_opts: dict[str, Any]) -> dict:\n        last_exc: Exception | None = None\n        for attempt in range(3):\n            try:\n                with YoutubeDL(local_opts) as ydl:\n                    info = ydl.extract_info(u, download=False)\n                if info and info.get(\"entries\"):\n                    info = info[\"entries\"][0]\n                return info or {}\n            except Exception as exc:  # pragma: no cover - dépend du réseau\n                last_exc = exc\n                msg = (str(exc) or \"\").lower()\n                if \"429\" in msg or \"too many requests\" in msg:\n                    _backoff_sleep(attempt)\n                    continue\n                raise\n        if last_exc:\n            raise last_exc\n        return {}\n\n    if browser_pref == \"cookiefile\" and cookies_path:\n        legacy_opts = dict(base_opts)\n        legacy_opts[\"cookiefile\"] = cookies_path\n        legacy_opts.pop(\"cookiesfrombrowser\", None)\n        try:\n            return _extract(legacy_opts)\n        except Exception:\n            # On tentera sans cookies juste après\n            pass\n\n    if browser_pref == \"none\":\n        opts_no_cookies = dict(base_opts)\n        opts_no_cookies.pop(\"cookiefile\", None)\n        opts_no_cookies.pop(\"cookiesfrombrowser\", None)\n        return _extract(opts_no_cookies)\n\n    last_error: Exception | None = None\n\n    browsers = _browser_fallback_order(cfg)\n    explicit_browser = browser_pref in BROWSER_TRY_ORDER\n    for browser in browsers:\n        local_opts = dict(base_opts)\n        local_opts[\"cookiesfrombrowser\"] = (browser, None, None, None)\n        try:\n            return _extract(local_opts)\n        except Exception as exc:\n            last_error = exc\n            msg = (str(exc) or \"\").lower()\n            if browser == \"firefox\" and (\"pycryptodomex\" in msg or \"cryptodome\" in msg):\n                if explicit_browser:\n                    raise RuntimeError(\n                        \"Lecture des cookies Firefox impossible : installez 'pycryptodomex' (pip install pycryptodomex).\"\n                    )\n                continue\n            if _is_dpapi_error(exc) or _is_chrome_copy_error(exc):\n                continue\n            raise\n\n    if browser_pref == \"auto\" and cookies_path:\n        legacy_opts = dict(base_opts)\n        legacy_opts[\"cookiefile\"] = cookies_path\n        legacy_opts.pop(\"cookiesfrombrowser\", None)\n        try:\n            return _extract(legacy_opts)\n        except Exception as exc:\n            last_error = exc\n\n    # Dernier recours : sans cookies\n    opts_no_cookies = dict(base_opts)\n    opts_no_cookies.pop(\"cookiefile\", None)\n    opts_no_cookies.pop(\"cookiesfrombrowser\", None)\n    try:\n        return _extract(opts_no_cookies)\n    except Exception as exc:\n        # Retourner l'erreur de la dernière tentative si ce n'est pas un problème de cookies\n        if not (_is_dpapi_error(exc) or _is_chrome_copy_error(exc)):\n            raise\n        if last_error and not (_is_dpapi_error(last_error) or _is_chrome_copy_error(last_error)):\n            raise last_error\n        raise RuntimeError(\n            \"Impossible de récupérer les informations vidéo : les cookies navigateur sont indisponibles et la requête sans cookies a échoué.\"\n        )\n\n    # Si aucune erreur n'a été levée, retourner un dict vide (pas censé arriver)\n    return {}\n\n# PATCH START: config persistante\nCONFIG_PATH = OUT_DIR / \"flowgrab_config.json\"\n\nDEFAULT_CONFIG = {\n    \"webhook_path\": \"/webhook/Audio\",\n    \"webhook_base\": \"\",\n    \"webhook_full\": \"\",\n    \"last_updated\": \"\",\n    \"telegram_token\": \"\",\n    \"telegram_mode\": \"polling\",\n    \"telegram_port\": 8081,\n    \"cookies_path\": \"\",\n    \"user_agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n    \"browser_cookies\": \"auto\",  # \"auto\" | navigateurs | \"cookiefile\" | \"none\"\n}\n\n\ndef _ensure_config_defaults(data: Optional[dict]) -> dict:\n    cfg = dict(DEFAULT_CONFIG)\n    if isinstance(data, dict):\n        for k, v in data.items():\n            if v is not None:\n                cfg[k] = v\n\n    bc = (cfg.get(\"browser_cookies\") or \"auto\").strip().lower()\n    allowed = {\n        \"auto\",\n        \"edge\",\n        \"chrome\",\n        \"firefox\",\n        \"brave\",\n        \"vivaldi\",\n        \"opera\",\n        \"chromium\",\n        \"cookiefile\",\n        \"none\",\n    }\n    cfg[\"browser_cookies\"] = bc if bc in allowed else \"auto\"\n\n    return cfg\n\n\ndef load_config() -> dict:\n    try:\n        import json\n        if CONFIG_PATH.exists():\n            data = json.loads(CONFIG_PATH.read_text(encoding=\"utf-8\"))\n            return _ensure_config_defaults(data)\n    except Exception:\n        pass\n    return _ensure_config_defaults(None)\n\n\ndef save_config(cfg: dict) -> None:\n    try:\n        import json\n        from datetime import datetime, timezone\n\n        merged = _ensure_config_defaults(cfg)\n        merged[\"last_updated\"] = datetime.now(timezone.utc).isoformat().replace(\"+00:00\", \"Z\")\n        CONFIG_PATH.write_text(json.dumps(merged, ensure_ascii=False, indent=2), encoding=\"utf-8\")\n    except Exception:\n        pass\n# PATCH END\nfrom dataclasses import dataclass\nfrom typing import Optional, List, Dict\n\nfrom PySide6.QtCore import (\n    Qt,\n    QThread,\n    Signal,\n    Slot,\n    QUrl,\n    QTimer,\n)\nfrom PySide6.QtGui import QAction, QPalette, QColor, QDesktopServices, QIcon\nfrom PySide6.QtWidgets import (\n    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLineEdit, QPushButton,\n    QListWidget, QListWidgetItem, QFileDialog, QLabel, QComboBox,\n    QProgressBar, QMessageBox, QGroupBox, QTabWidget, QTableWidget,\n    QTableWidgetItem,\n    QAbstractItemView,\n    QSpinBox,\n)\nfrom PySide6.QtWidgets import QTextEdit\n\ntry:\n    from shiboken6 import isValid as _shiboken_is_valid\nexcept Exception:  # pragma: no cover - fallback si shiboken6 absent\n    def _shiboken_is_valid(obj):  # type: ignore[return-type]\n        return obj is not None\n\ntry:\n    from flask import Flask\nexcept ImportError:  # pragma: no cover - dépend de l'environnement\n    Flask = None  # type: ignore[assignment]\n\ntry:  # thème optionnel moderne\n    import qdarktheme\n\n    HAS_QDT = True\nexcept Exception:  # pragma: no cover - dépend des packages installés\n    HAS_QDT = False\n\n\n_notification_server_started = False\n_notification_parent_widget = None\n\n\ndef _send_windows_notification(message: str) -> None:\n    if not sys.platform.startswith(\"win\"):\n        return\n    try:\n        from win10toast import ToastNotifier  # optionnel\n        ToastNotifier().show_toast(\"FlowGrab\", message, duration=5, threaded=True)\n        return\n    except Exception:\n        pass\n    try:\n        creationflags = getattr(subprocess, \"CREATE_NO_WINDOW\", 0)\n        subprocess.Popen([\n            \"cmd\",\n            \"/c\",\n            \"msg\",\n            \"*\",\n            message,\n        ], creationflags=creationflags)\n    except Exception:\n        pass\n\n\ndef _is_list_item_valid(item: Optional[QListWidgetItem]) -> bool:\n    try:\n        return bool(item) and _shiboken_is_valid(item)\n    except Exception:\n        return False\n\n\ndef start_notification_server(parent_widget=None) -> None:\n    global _notification_server_started, _notification_parent_widget\n    if _notification_server_started:\n        return\n\n    _notification_parent_widget = parent_widget\n\n    if Flask is None:\n        def warn_missing_flask():\n            parent = _notification_parent_widget\n            QMessageBox.warning(\n                parent,\n                \"Flask manquant\",\n                \"Impossible de démarrer le serveur de notification.\\n\"\n                \"Installe Flask avec 'pip install flask' pour activer les notifications.\",\n            )\n\n        QTimer.singleShot(0, warn_missing_flask)\n        _notification_server_started = True\n        return\n\n    from flask import request  # import ici pour éviter conflit avec l'import conditionnel global\n    flask_app = Flask(\"flowgrab-notify\")\n    TOKEN = os.environ.get(\"FG_NOTIFY_TOKEN\", \"change_me\")\n\n    @flask_app.get(\"/notify-done\")\n    def notify_done():  # pragma: no cover - exécuté via requête HTTP\n        if request.args.get(\"token\") != TOKEN:\n            return {\"status\": \"forbidden\"}, 403\n\n        def _purge_transcription_segments_and_audio():\n            try:\n                if TRANSCRIPTION_DIR.exists():\n                    for p in TRANSCRIPTION_DIR.glob(\"audio_partie_*.aac\"):\n                        try:\n                            if p.is_file():\n                                p.unlink()\n                        except Exception:\n                            pass\n                    for p in TRANSCRIPTION_DIR.glob(\"*.mp3\"):\n                        try:\n                            if p.is_file():\n                                p.unlink()\n                        except Exception:\n                            pass\n\n                horizon = time.time() - 3600\n                if AUDIOS_DIR.exists():\n                    for p in AUDIOS_DIR.iterdir():\n                        if not p.is_file():\n                            continue\n                        if p.suffix.lower() not in {\".mp3\", \".m4a\", \".wav\", \".ogg\", \".flac\"}:\n                            continue\n                        try:\n                            stat = p.stat()\n                        except Exception:\n                            continue\n                        if stat.st_size <= 0:\n                            continue\n                        if stat.st_mtime >= horizon:\n                            try:\n                                p.unlink()\n                            except Exception:\n                                pass\n            except Exception:\n                pass\n\n        def show_message_box():\n            parent = _notification_parent_widget\n            if parent is not None and hasattr(parent, \"isVisible\") and not parent.isVisible():\n                parent = None\n            if parent is None:\n                parent = QApplication.activeWindow()\n            QMessageBox.information(parent, \"Notification N8N\", \"La transcription est terminée.\")\n\n        QTimer.singleShot(0, show_message_box)\n        QTimer.singleShot(0, _purge_transcription_segments_and_audio)\n        threading.Thread(target=_send_windows_notification, args=(\"La transcription est terminée.\",), daemon=True).start()\n        return {\"status\": \"ok\"}\n\n    def run_flask():  # pragma: no cover - serveur en arrière-plan\n        try:\n            flask_app.run(host=\"127.0.0.1\", port=5050, debug=False, use_reloader=False)\n        except Exception as exc:\n            def warn_error():\n                parent = _notification_parent_widget\n                QMessageBox.warning(\n                    parent,\n                    \"Serveur Flask\",\n                    f\"Erreur lors du démarrage du serveur Flask : {exc}\",\n                )\n\n            QTimer.singleShot(0, warn_error)\n\n    threading.Thread(target=run_flask, daemon=True).start()\n    _notification_server_started = True\nfrom yt_dlp import YoutubeDL\n\n# ---------------------- Modèle de tâche ----------------------\n@dataclass\nclass Task:\n    url: str\n    status: str = \"En attente\"\n    filename: str = \"\"\n    total: int = 0\n    downloaded: int = 0\n    speed: float = 0.0\n    eta: Optional[int] = None\n    video_id: Optional[str] = None  # pour nettoyage\n    selected_fmt: Optional[str] = None\n    final_audio_path: Optional[str] = None\n    final_video_path: Optional[str] = None\n    # Telegram\n    source: str = \"ui\"                 # \"ui\" | \"telegram\"\n    chat_id: Optional[int] = None\n\n# ---------------------- Worker de téléchargement ----------------------\nclass DownloadWorker(QThread):\n    sig_progress = Signal(object, object, float, int, str)     # downloaded, total, speed, eta, filename\n    sig_status   = Signal(str)                           # statut court\n    sig_done     = Signal(bool, str, dict)               # ok, message/chemin, info dict\n\n    def __init__(self, task: Task, ydl_opts: dict, parent=None):\n        super().__init__(parent)\n        self.task = task\n        self.ydl_opts = ydl_opts\n        self._stop = False\n\n    def stop(self):\n        self._stop = True\n\n    def run(self):\n        captured = {\"fn\": \"\"}\n\n        def hook(d):\n            if self._stop:\n                raise Exception(\"Interrompu par l’utilisateur\")\n            st = d.get(\"status\")\n            if st == \"downloading\":\n                downloaded = int(d.get(\"downloaded_bytes\") or 0)\n                total = int(d.get(\"total_bytes\") or d.get(\"total_bytes_estimate\") or 0)\n                speed = float(d.get(\"speed\") or 0.0)\n                eta   = int(d.get(\"eta\") or 0)\n                fn    = d.get(\"filename\") or self.task.filename or \"\"\n                self.sig_progress.emit(downloaded, total, speed, eta, fn)\n            elif st == \"finished\":\n                captured[\"fn\"] = d.get(\"filename\") or captured[\"fn\"]\n                self.sig_status.emit(f\"Terminé : {captured['fn']}\")\n\n        opts = dict(self.ydl_opts)\n        opts[\"progress_hooks\"] = [hook]\n        opts[\"quiet\"] = True\n        opts[\"no_warnings\"] = True\n        opts[\"logger\"] = YtdlpLogger(lambda msg: self.sig_status.emit(msg))\n\n        cfg = load_config()\n        user_agent = (cfg.get(\"user_agent\") or \"\").strip()\n        headers: dict[str, str] = {}\n        if user_agent:\n            headers = dict(opts.get(\"http_headers\") or {})\n            headers[\"User-Agent\"] = user_agent\n            opts[\"http_headers\"] = headers\n\n        try:\n            url = normalize_url(self.task.url)\n            cookies_path = (cfg.get(\"cookies_path\") or \"\").strip()\n            browser_pref = (cfg.get(\"browser_cookies\") or \"auto\").strip().lower()\n\n            base_opts = dict(opts)\n            base_opts.pop(\"cookiefile\", None)\n            base_opts.pop(\"cookiesfrombrowser\", None)\n\n            def _download_with_opts(local_opts: dict[str, Any]) -> tuple[dict[str, Any], int]:\n                last_exc: Exception | None = None\n                for attempt in range(3):\n                    try:\n                        with YoutubeDL(local_opts) as ydl:\n                            info_inner = ydl.extract_info(url, download=True)\n                            ret = getattr(ydl, \"_download_retcode\", 0) or 0\n                        return info_inner, ret\n                    except Exception as exc:\n                        last_exc = exc\n                        msg = (str(exc) or \"\").lower()\n                        if \"429\" in msg or \"too many requests\" in msg:\n                            self.sig_status.emit(\"yt-dlp : HTTP 429, nouvelle tentative…\")\n                            _backoff_sleep(attempt)\n                            continue\n                        raise\n                if last_exc:\n                    raise last_exc\n                return {}, 0\n\n            info: dict[str, Any] = {}\n            retcode = 0\n            dpapi_or_copy_issue = False\n            last_error: Exception | None = None\n            used_no_cookies = False\n            success = False\n\n            pycryptodomex_hint = \"Lecture cookies Firefox impossible : installez 'pycryptodomex' (pip install pycryptodomex).\"\n\n            def try_cookiefile() -> bool:\n                nonlocal info, retcode, opts, last_error\n                if not cookies_path:\n                    return False\n                local_opts = dict(base_opts)\n                local_opts[\"cookiefile\"] = cookies_path\n                local_opts.pop(\"cookiesfrombrowser\", None)\n                try:\n                    info, retcode = _download_with_opts(local_opts)\n                    opts = local_opts\n                    return True\n                except Exception as exc:\n                    last_error = exc\n                    return False\n\n            def try_browser(browser: str, explicit: bool) -> bool:\n                nonlocal info, retcode, opts, last_error, dpapi_or_copy_issue\n                local_opts = dict(base_opts)\n                local_opts[\"cookiesfrombrowser\"] = (browser, None, None, None)\n                try:\n                    info, retcode = _download_with_opts(local_opts)\n                    opts = local_opts\n                    return True\n                except Exception as exc:\n                    last_error = exc\n                    msg = (str(exc) or \"\").lower()\n                    if browser == \"firefox\" and (\"pycryptodomex\" in msg or \"cryptodome\" in msg):\n                        self.sig_status.emit(pycryptodomex_hint)\n                        if explicit:\n                            raise RuntimeError(pycryptodomex_hint)\n                        return False\n                    if _is_dpapi_error(exc) or _is_chrome_copy_error(exc):\n                        dpapi_or_copy_issue = True\n                        return False\n                    raise\n\n            def try_no_cookies() -> bool:\n                nonlocal info, retcode, opts, last_error\n                local_opts = dict(base_opts)\n                local_opts.pop(\"cookiefile\", None)\n                local_opts.pop(\"cookiesfrombrowser\", None)\n                try:\n                    info, retcode = _download_with_opts(local_opts)\n                    opts = local_opts\n                    return True\n                except Exception as exc:\n                    last_error = exc\n                    return False\n\n            if browser_pref == \"cookiefile\":\n                success = try_cookiefile()\n            elif browser_pref == \"none\":\n                success = try_no_cookies()\n                used_no_cookies = True\n            else:\n                browsers = _browser_fallback_order(cfg)\n                explicit = browser_pref in BROWSER_TRY_ORDER\n                for browser in browsers:\n                    if try_browser(browser, explicit):\n                        success = True\n                        break\n\n                if not success and browser_pref == \"auto\" and try_cookiefile():\n                    success = True\n\n            if not success and not used_no_cookies:\n                if dpapi_or_copy_issue:\n                    self.sig_status.emit(\n                        \"Cookies navigateur indisponibles (DPAPI/DB verrouillée). Passage en mode sans cookies.\"\n                    )\n                success = try_no_cookies()\n                used_no_cookies = True\n\n            if not success:\n                if last_error is not None:\n                    raise last_error\n                raise RuntimeError(\"Téléchargement impossible : toutes les stratégies de cookies ont échoué.\")\n\n            fn = captured[\"fn\"]\n            if not fn and info:\n                try:\n                    rd = (info.get(\"requested_downloads\") or [])\n                    if rd:\n                        fn = rd[0].get(\"filepath\") or rd[0].get(\"filename\") or \"\"\n                except Exception:\n                    pass\n\n            if not info:\n                reused_info = {}\n                if retcode == 0:\n                    try:\n                        reused_info = extract_basic_info(url)\n                    except Exception:\n                        reused_info = {}\n\n                if reused_info and retcode == 0:\n                    video_id = reused_info.get(\"id\") or \"\"\n                    existing = find_existing_outputs(video_id)\n                    if (not video_id) or (not existing.get(\"audio\") and not existing.get(\"video\")):\n                        raise RuntimeError(\n                            \"Téléchargement déjà enregistré dans l’archive mais aucun fichier final n’a été retrouvé. \"\n                            \"Supprime l’entrée correspondante dans archive.txt pour forcer un nouveau téléchargement.\"\n                        )\n                    if existing.get(\"audio\"):\n                        self.task.final_audio_path = existing[\"audio\"]\n                    if existing.get(\"video\"):\n                        self.task.final_video_path = existing[\"video\"]\n                    reuse_msg = existing.get(\"audio\") or existing.get(\"video\") or \"Déjà téléchargé (archive)\"\n                    if video_id:\n                        self.task.video_id = video_id\n                    self.sig_status.emit(\"Déjà téléchargé (archive)\")\n                    self.sig_done.emit(True, reuse_msg, reused_info or {})\n                    return\n\n                raise RuntimeError(\"yt-dlp n’a renvoyé aucune information (URL invalide, vidéo privée ou cookies requis).\")\n\n            if fn:\n                self.task.filename = fn\n\n            self.sig_done.emit(True, fn or \"Téléchargement terminé\", info or {})\n        except Exception as e:\n            self.sig_done.emit(False, str(e), {})\n\nclass CommandWorker(QThread):\n    sig_line = Signal(str)      # lignes de log\n    sig_done = Signal(int)      # code retour\n\n    def __init__(self, cmd: list[str], cwd: pathlib.Path | None = None, env: dict | None = None, parent=None):\n        super().__init__(parent)\n        self.cmd = cmd\n        self.cwd = str(cwd) if cwd else None\n        self.env = env\n\n    def run(self):\n        try:\n            proc = subprocess.Popen(\n                self.cmd,\n                cwd=self.cwd,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.STDOUT,\n                text=True,\n                env=self.env,\n                shell=False,\n            )\n            assert proc.stdout is not None\n            for line in proc.stdout:\n                self.sig_line.emit(line.rstrip())\n            proc.wait()\n            self.sig_done.emit(proc.returncode or 0)\n        except Exception as e:\n            self.sig_line.emit(f\"[ERREUR] {e}\")\n            self.sig_done.emit(1)\n\n\nclass InspectWorker(QThread):\n    sig_done  = Signal(str, dict)   # url, info\n    sig_error = Signal(str, str)    # url, message\n\n    def __init__(self, url: str, parent=None):\n        super().__init__(parent)\n        self.url = url\n\n    def run(self):\n        try:\n            info = extract_basic_info(self.url)\n            self.sig_done.emit(self.url, info or {})\n        except Exception as e:\n            self.sig_error.emit(self.url, str(e))\n\n\nclass LongProcWorker(QThread):\n    \"\"\"Lance un processus long (ex: script PowerShell), stream les logs, et permet un stop propre.\"\"\"\n\n    sig_line = Signal(str)     # ligne de log\n    sig_started = Signal(int)  # pid\n    sig_done = Signal(int)     # code retour\n\n    def __init__(self, args: list[str], env: dict | None = None, parent=None):\n        super().__init__(parent)\n        self.args = args\n        self.env = env\n        self.proc: subprocess.Popen | None = None\n\n    def run(self):\n        try:\n            creationflags = 0\n            if sys.platform.startswith(\"win\"):\n                # pour pouvoir envoyer CTRL_BREAK_EVENT et tuer l'arbre si besoin\n                creationflags = getattr(subprocess, \"CREATE_NEW_PROCESS_GROUP\", 0)\n            self.proc = subprocess.Popen(\n                self.args,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.STDOUT,\n                text=True,\n                shell=False,\n                env=self.env,\n                creationflags=creationflags,\n            )\n            assert self.proc.stdout is not None\n            self.sig_started.emit(self.proc.pid or 0)\n            for line in self.proc.stdout:\n                self.sig_line.emit(line.rstrip())\n            self.proc.wait()\n            self.sig_done.emit(self.proc.returncode or 0)\n        except Exception as e:\n            self.sig_line.emit(f\"[ERREUR] {e}\")\n            self.sig_done.emit(1)\n\n    def stop(self):\n        if not self.proc:\n            return\n        # PATCH START: stop propre + wait court\n        try:\n            if sys.platform.startswith(\"win\"):\n                self.proc.send_signal(signal.CTRL_BREAK_EVENT)\n                try:\n                    self.proc.wait(timeout=3)\n                except Exception:\n                    pass\n        except Exception:\n            pass\n        try:\n            self.proc.terminate()\n        except Exception:\n            pass\n        try:\n            subprocess.run([\n                \"taskkill\",\n                \"/PID\",\n                str(self.proc.pid),\n                \"/T\",\n                \"/F\",\n            ], capture_output=True, text=True)\n        except Exception:\n            pass\n        # PATCH END\n\n\ndef _apply_qdarktheme(app: QApplication, theme: str) -> bool:\n    if not HAS_QDT:\n        return False\n    # Compatibilité avec qdarktheme>=2 (setup_theme) et <2 (load_stylesheet).\n    setup = getattr(qdarktheme, \"setup_theme\", None)\n    if callable(setup):\n        setup(theme)\n        return True\n    loader = getattr(qdarktheme, \"load_stylesheet\", None)\n    if callable(loader):\n        app.setStyleSheet(loader(theme))\n        return True\n    return False\n\n\n# ---------------------- Thèmes ----------------------\ndef apply_dark_theme(app: QApplication):\n    if _apply_qdarktheme(app, \"dark\"):\n        return\n    app.setStyle(\"Fusion\")\n    palette = QPalette()\n    bg = QColor(30, 30, 30)\n    base = QColor(40, 40, 40)\n    text = QColor(220, 220, 220)\n    disabled = QColor(127, 127, 127)\n    highlight = QColor(53, 132, 228)\n\n    palette.setColor(QPalette.Window, bg)\n    palette.setColor(QPalette.WindowText, text)\n    palette.setColor(QPalette.Base, base)\n    palette.setColor(QPalette.AlternateBase, bg)\n    palette.setColor(QPalette.ToolTipBase, base)\n    palette.setColor(QPalette.ToolTipText, text)\n    palette.setColor(QPalette.Text, text)\n    palette.setColor(QPalette.Button, base)\n    palette.setColor(QPalette.ButtonText, text)\n    palette.setColor(QPalette.BrightText, QColor(255, 0, 0))\n    palette.setColor(QPalette.Highlight, highlight)\n    palette.setColor(QPalette.HighlightedText, QColor(255, 255, 255))\n    palette.setColor(QPalette.Disabled, QPalette.Text, disabled)\n    palette.setColor(QPalette.Disabled, QPalette.ButtonText, disabled)\n    app.setPalette(palette)\n\n\ndef apply_light_theme(app: QApplication):\n    if _apply_qdarktheme(app, \"light\"):\n        return\n    app.setStyle(\"Fusion\")\n    app.setPalette(QApplication.style().standardPalette())\n\n# ---------------------- Utilitaires affichage ----------------------\ndef human_size(n: Optional[float]) -> str:\n    if not n or n <= 0: return \"—\"\n    n = float(n)\n    for unit in (\"o\",\"Ko\",\"Mo\",\"Go\",\"To\"):\n        if n < 1024.0:\n            return f\"{n:.1f} {unit}\"\n        n /= 1024.0\n    return f\"{n:.1f} Po\"\n\ndef human_rate(v: float) -> str:\n    if not v: return \"—/s\"\n    for unit in (\"o/s\",\"Ko/s\",\"Mo/s\",\"Go/s\"):\n        if v < 1024.0:\n            return f\"{v:.1f} {unit}\"\n        v /= 1024.0\n    return f\"{v:.1f} To/s\"\n\ndef human_eta(s: Optional[int]) -> str:\n    if not s: return \"—\"\n    m, sec = divmod(int(s), 60)\n    h, m = divmod(m, 60)\n    if h: return f\"{h:d}h {m:02d}m {sec:02d}s\"\n    if m: return f\"{m:d}m {sec:02d}s\"\n    return f\"{sec:d}s\"\n\n# ---------------------- Inspecteur de formats ----------------------\ndef pick_best_audio(formats: List[dict], mp4_friendly: bool) -> Optional[dict]:\n    audios = [f for f in formats if f.get(\"vcodec\") in (None, \"none\")]\n    if mp4_friendly:\n        preferred = [f for f in audios if (f.get(\"ext\") in (\"m4a\",\"mp4\",\"aac\") or (f.get(\"acodec\",\"\" ).startswith(\"mp4a.\")))]\n        if preferred:\n            return sorted(preferred, key=lambda x: x.get(\"tbr\") or 0, reverse=True)[0]\n    if audios:\n        return sorted(audios, key=lambda x: x.get(\"tbr\") or 0, reverse=True)[0]\n    return None\n\ndef list_video_formats(formats: List[dict], mp4_friendly: bool) -> List[dict]:\n    vids = [f for f in formats if f.get(\"acodec\") in (None, \"none\") and f.get(\"vcodec\") not in (None, \"none\")]\n    if mp4_friendly:\n        vids = [f for f in vids if (f.get(\"ext\") == \"mp4\" or \"avc1\" in (f.get(\"vcodec\") or \"\"))]\n    return sorted(vids, key=lambda x: (x.get(\"height\") or 0, x.get(\"tbr\") or 0), reverse=True)\n\ndef estimate_size(stream: dict, duration: Optional[float]) -> Optional[float]:\n    size = stream.get(\"filesize\") or stream.get(\"filesize_approx\")\n    if size: return float(size)\n    tbr = stream.get(\"tbr\")  # kbps\n    if duration and tbr:\n        return float(tbr) * 1000.0 / 8.0 * float(duration)\n    return None\n\n# ---------------------- Telegram worker ----------------------\nclass TelegramWorker(QThread):\n    # chat_id peut dépasser la taille d'un int 32 bits -> utiliser \"object\"\n    sig_download_requested = Signal(str, str, object, str)  # url, fmt, chat_id, title\n    sig_info = Signal(str)\n\n    def __init__(self, app_config: dict, parent=None):\n        super().__init__(parent)\n        self.app_config = app_config\n        self._loop: asyncio.AbstractEventLoop | None = None\n        self._stop_evt: asyncio.Event | None = None\n        self.app: \"Application | None\" = None\n        self._pending_choices: Dict[str, Dict[str, Any]] = {}\n        self.effective_mode = self._resolve_mode()\n        # Map token -> chemin audio à transcrire (évite de dépasser la limite Telegram 64o sur callback_data)\n        self._pending_transcriptions: Dict[str, str] = {}\n\n    # ---- helpers ----\n    def _resolve_mode(self) -> str:\n        return \"polling\"\n\n    def send_message(self, chat_id: int | str, text: str, reply_markup: Any = None) -> None:\n        if not self._loop or not self.app:\n            return\n\n        try:\n            chat_ref: int | str = int(chat_id)  # Telegram accepte les entiers Python arbitraires\n        except (TypeError, ValueError):\n            chat_ref = chat_id\n\n        async def _send():\n            try:\n                await self.app.bot.send_message(chat_id=chat_ref, text=text, reply_markup=reply_markup)\n            except Exception as exc:\n                self.sig_info.emit(f\"Envoi message Telegram impossible : {exc}\")\n\n        self._loop.call_soon_threadsafe(lambda: asyncio.create_task(_send()))\n\n    def ask_transcription(self, chat_id: int | str, audio_path: str) -> None:\n        from telegram import InlineKeyboardButton, InlineKeyboardMarkup\n\n        token = secrets.token_urlsafe(8)  # court, sûr, << 64 octets\n        self._pending_transcriptions[token] = audio_path\n        name = os.path.basename(audio_path) or audio_path\n        buttons = [\n            [InlineKeyboardButton(\"📝 Oui, transcrire\", callback_data=f\"tr:yes:{token}\")],\n            [InlineKeyboardButton(\"⛔ Non\", callback_data=f\"tr:no:{token}\")],\n        ]\n        self.send_message(chat_id, f\"Transcrire l’audio téléchargé ?\\n{name}\", InlineKeyboardMarkup(buttons))\n\n    # ---- yt-dlp helpers ----\n    def _inspect_url(self, url: str) -> dict:\n        u = normalize_yt(url)\n        ydl_opts = {\n            \"quiet\": True,\n            \"no_warnings\": True,\n            \"retries\": 2,\n            \"socket_timeout\": 15,\n        }\n        with YoutubeDL(ydl_opts) as ydl:\n            info = ydl.extract_info(u, download=False)\n        if info and info.get(\"entries\"):\n            info = info[\"entries\"][0]\n        return info or {}\n\n    def _build_options(self, info: dict) -> Tuple[str, List[Dict[str, Any]]]:\n        formats = info.get(\"formats\") or []\n        duration = info.get(\"duration\")\n        videos = list_video_formats(formats, mp4_friendly=True)\n        audio = pick_best_audio(formats, mp4_friendly=True)\n        title = info.get(\"title\") or info.get(\"fulltitle\") or info.get(\"original_url\") or \"Lien YouTube\"\n        options: List[Dict[str, Any]] = []\n        for vf in videos[:8]:\n            vid_id = vf.get(\"format_id\") or \"\"\n            fmt = vid_id\n            audio_id = \"\"\n            audio_label = \"\"\n            audio_size = None\n            if audio:\n                audio_id = audio.get(\"format_id\") or \"\"\n                if audio_id:\n                    fmt = f\"{vid_id}+{audio_id}\"\n                audio_label = f\"{audio.get('ext','')}/{audio.get('acodec','')}\"\n                audio_size = estimate_size(audio, duration)\n            res = f\"{vf.get('height') or ''}p\"\n            fps = vf.get(\"fps\")\n            vc = f\"{vf.get('ext','')}/{vf.get('vcodec','')}\"\n            vsize = estimate_size(vf, duration)\n            total = (vsize or 0) + (audio_size or 0)\n            parts = [res.strip() or \"—\", vc]\n            if fps:\n                parts.insert(1, f\"{fps} fps\")\n            label = \" • \".join([p for p in parts if p])\n            approx = human_size(total) if total else \"—\"\n            detail = label\n            if audio_label:\n                detail += f\" • Audio {audio_label}\"\n            detail += f\" • ≈ {approx}\"\n            options.append({\n                \"fmt\": fmt,\n                \"label\": detail,\n            })\n        return title, options\n\n    # ---- PTB callbacks ----\n    async def _cmd_start(self, update, context):\n        msg = update.effective_message\n        if msg:\n            await msg.reply_text(\"Envoie-moi un lien YouTube pour lancer un téléchargement.\")\n\n    async def _handle_text(self, update, context):\n        message = update.effective_message\n        if not message:\n            return\n        text = (message.text or \"\").strip()\n        match = YOUTUBE_REGEX.search(text)\n        if not match:\n            await message.reply_text(\"Je n’ai pas reconnu de lien YouTube. Envoie l’URL complète.\")\n            return\n        url = normalize_yt(match.group(1))\n        await message.reply_text(\"Analyse du lien…\")\n        loop = asyncio.get_running_loop()\n        try:\n            info = await loop.run_in_executor(None, self._inspect_url, url)\n        except Exception as exc:\n            self.sig_info.emit(f\"Inspection Telegram échouée : {exc}\")\n            await message.reply_text(\"Impossible d’inspecter cette vidéo. Réessaie plus tard.\")\n            return\n\n        title, options = self._build_options(info)\n        if not options:\n            await message.reply_text(\"Aucun format compatible trouvé pour cette vidéo.\")\n            return\n\n        token = secrets.token_urlsafe(4)\n        self._pending_choices[token] = {\n            \"url\": url,\n            \"options\": options,\n            \"title\": title,\n        }\n\n        lines = [f\"Formats disponibles pour « {title} » :\", \"\"]\n        for idx, opt in enumerate(options, start=1):\n            lines.append(f\"{idx}. {opt['label']}\")\n        lines.append(\"\")\n        lines.append(\"Choisis un format via les boutons ci-dessous.\")\n\n        from telegram import InlineKeyboardButton, InlineKeyboardMarkup\n\n        buttons: List[List[Any]] = []\n        row: List[Any] = []\n        for idx in range(len(options)):\n            row.append(InlineKeyboardButton(str(idx + 1), callback_data=f\"choose:{token}:{idx}\"))\n            if len(row) == 4:\n                buttons.append(row)\n                row = []\n        if row:\n            buttons.append(row)\n\n        markup = InlineKeyboardMarkup(buttons)\n        await message.reply_text(\"\\n\".join(lines), reply_markup=markup)\n\n    async def _handle_callback(self, update, context):\n        query = update.callback_query\n        if not query:\n            return\n        data = query.data or \"\"\n        chat = query.message.chat if query.message else update.effective_chat\n        chat_id = chat.id if chat else None\n\n        if data.startswith(\"choose:\"):\n            parts = data.split(\":\", 2)\n            if len(parts) != 3:\n                await query.answer(\"Choix invalide.\")\n                return\n            token, idx_str = parts[1], parts[2]\n            entry = self._pending_choices.get(token)\n            if not entry:\n                await query.answer(\"Choix expiré.\")\n                try:\n                    await query.edit_message_reply_markup(None)\n                except Exception:\n                    pass\n                return\n            try:\n                idx = int(idx_str)\n            except ValueError:\n                await query.answer(\"Choix invalide.\")\n                return\n            options = entry.get(\"options\") or []\n            if idx < 0 or idx >= len(options):\n                await query.answer(\"Choix invalide.\")\n                return\n            option = options[idx]\n            if chat_id is None:\n                await query.answer(\"Chat introuvable.\")\n                return\n            await query.answer(\"Téléchargement en cours…\", show_alert=False)\n            try:\n                await query.edit_message_reply_markup(None)\n            except Exception:\n                pass\n            title = entry.get(\"title\") or \"Vidéo\"\n            fmt = option.get(\"fmt\") or \"\"\n            self.sig_download_requested.emit(entry.get(\"url\", \"\"), fmt, chat_id, title)\n            self.send_message(chat_id, f\"Format sélectionné : {option.get('label','')}\\nTéléchargement demandé…\")\n            self._pending_choices.pop(token, None)\n        elif data.startswith(\"tr:yes\"):\n            parts = data.split(\":\", 2)\n            tok = parts[2] if len(parts) == 3 else \"\"\n            audio_path = self._pending_transcriptions.pop(tok, \"\")\n            if not audio_path:\n                await query.answer(\"Lien expiré. Renvoie la vidéo pour réessayer.\", show_alert=True)\n                return\n            await self._handle_transcription_yes(query, chat_id, audio_path)\n        elif data.startswith(\"tr:no\"):\n            await query.answer(\"OK\", show_alert=False)\n            try:\n                await query.edit_message_reply_markup(None)\n            except Exception:\n                pass\n            if chat_id is not None:\n                self.send_message(chat_id, \"Transcription annulée.\")\n        else:\n            await query.answer(\"Commande inconnue.\")\n\n    async def _handle_transcription_yes(self, query, chat_id: Optional[int], audio_path: str):\n        if chat_id is None:\n            await query.answer(\"Chat introuvable.\")\n            return\n        webhook_full = (self.app_config.get(\"webhook_full\") or \"\").strip()\n        if not webhook_full:\n            await query.answer(\"Webhook non configuré.\", show_alert=True)\n            self.send_message(chat_id, \"Configure le webhook dans l’app avant de lancer une transcription.\")\n            return\n        await query.answer(\"Envoi en cours…\", show_alert=False)\n        loop = asyncio.get_running_loop()\n        status, body = await loop.run_in_executor(None, self._post_audio_to_webhook, webhook_full, audio_path)\n        try:\n            await query.edit_message_reply_markup(None)\n        except Exception:\n            pass\n        if status == 0:\n            self.send_message(chat_id, f\"Transcription impossible : {body}\")\n            return\n        snippet = body.strip()\n        if len(snippet) > 400:\n            snippet = snippet[:400] + \"\\n...[tronqué]...\"\n        msg = f\"Transcription lancée ✅ (HTTP {status})\"\n        if snippet:\n            msg += f\"\\n{snippet}\"\n        self.send_message(chat_id, msg)\n\n    def _post_audio_to_webhook(self, url: str, audio_path: str) -> Tuple[int, str]:\n        try:\n            import requests\n        except ImportError:\n            return 0, \"Le module requests est manquant. Installe-le depuis l’app.\"\n        if not os.path.exists(audio_path):\n            return 0, f\"Fichier introuvable : {audio_path}\"\n        mime, _ = mimetypes.guess_type(audio_path)\n        mime = mime or \"application/octet-stream\"\n        basename = os.path.basename(audio_path)\n        try:\n            with open(audio_path, \"rb\") as handle:\n                files = {\"data\": (basename, handle, mime)}\n                resp = requests.post(url, files=files, timeout=(10, 600))\n            body = resp.text or \"\"\n            return resp.status_code, body\n        except Exception as exc:\n            return 0, str(exc)\n\n    # ---- QThread API ----\n    def run(self):\n        token = (self.app_config.get(\"telegram_token\") or \"\").strip()\n        if not token:\n            self.sig_info.emit(\"Token Telegram manquant : bot non démarré.\")\n            return\n\n        if sys.platform.startswith(\"win\"):\n            try:\n                asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n            except Exception:\n                pass\n\n        try:\n            self._loop = asyncio.new_event_loop()\n        except Exception as exc:\n            self.sig_info.emit(f\"Erreur bot Telegram : {exc}\")\n            return\n\n        try:\n            asyncio.set_event_loop(self._loop)\n            self._stop_evt = asyncio.Event()\n            mode = self._resolve_mode()\n            base = (self.app_config.get(\"webhook_base\") or \"\").strip()\n            if mode == \"webhook\" and not base:\n                self.sig_info.emit(\"URL webhook absente, bascule en mode polling.\")\n                mode = \"polling\"\n            self.effective_mode = mode\n            major, minor = _ptb_major_minor()\n            self.sig_info.emit(f\"python-telegram-bot v{major}.{minor}\")\n\n            if mode == \"polling\":\n                self._loop.run_until_complete(self._serve_polling())\n            else:\n                port = int(self.app_config.get(\"telegram_port\") or 8081)\n                self._loop.run_until_complete(self._serve_webhook(base, port))\n        except Exception as exc:\n            self.sig_info.emit(f\"Erreur bot Telegram : {exc}\")\n        finally:\n            if self._loop:\n                try:\n                    self._loop.close()\n                except Exception:\n                    pass\n            self._loop = None\n            self._stop_evt = None\n            self.app = None\n            self._pending_choices.clear()\n            self.sig_info.emit(\"Bot Telegram arrêté.\")\n\n    async def _build_app(self):\n        try:\n            from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters\n        except Exception as exc:\n            raise RuntimeError(f\"Import python-telegram-bot impossible : {exc}\") from exc\n\n        token = (self.app_config.get(\"telegram_token\") or \"\").strip()\n        app = Application.builder().token(token).build()\n        self.app = app\n        app.add_handler(CommandHandler(\"start\", self._cmd_start))\n        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self._handle_text))\n        app.add_handler(CallbackQueryHandler(self._handle_callback))\n        return app\n\n    async def _serve_polling(self):\n        self.sig_info.emit(\"Bot Telegram en initialisation (polling)…\")\n        try:\n            app = await self._build_app()\n        except RuntimeError as exc:\n            self.sig_info.emit(str(exc))\n            return\n        await app.initialize()\n        await app.start()\n        try:\n            await app.bot.delete_webhook(drop_pending_updates=True)\n        except Exception:\n            pass\n\n        if app.updater is None:\n            self.sig_info.emit(\"Updater PTB indisponible : polling impossible.\")\n            try:\n                await app.stop()\n            except Exception:\n                pass\n            try:\n                await app.shutdown()\n            except Exception:\n                pass\n            return\n\n        try:\n            await app.updater.start_polling(drop_pending_updates=False)\n        except Exception as exc:\n            self.sig_info.emit(f\"start_polling a échoué : {exc}\")\n            try:\n                await app.updater.stop()\n            except Exception:\n                pass\n            try:\n                await app.stop()\n            except Exception:\n                pass\n            try:\n                await app.shutdown()\n            except Exception:\n                pass\n            return\n\n        self.sig_info.emit(\"Bot Telegram démarré en mode polling.\")\n        try:\n            if self._stop_evt:\n                await self._stop_evt.wait()\n        finally:\n            try:\n                await app.updater.stop()\n            except Exception:\n                pass\n            try:\n                await app.stop()\n            except Exception:\n                pass\n            try:\n                await app.shutdown()\n            except Exception:\n                pass\n\n    async def _serve_webhook(self, base: str, port: int):\n        self.sig_info.emit(\"Bot Telegram en initialisation (webhook)…\")\n        try:\n            app = await self._build_app()\n        except RuntimeError as exc:\n            self.sig_info.emit(str(exc))\n            return\n\n        await app.initialize()\n        await app.start()\n        token = (self.app_config.get(\"telegram_token\") or \"\").strip()\n        path = f\"tg/{token}\"\n        base = base.rstrip(\"/\")\n        webhook_url = f\"{base}/{path}\" if base else f\"/{path}\"\n\n        try:\n            from telegram import Update\n            await app.bot.set_webhook(url=webhook_url, allowed_updates=Update.ALL_TYPES)\n            await app.start_webhook(\n                listen=\"0.0.0.0\",\n                port=port,\n                url_path=path,\n                webhook_url=webhook_url,\n                drop_pending_updates=True,\n            )\n        except Exception as exc:\n            self.sig_info.emit(f\"Impossible de démarrer le webhook : {exc}\")\n            try:\n                await app.stop()\n            except Exception:\n                pass\n            try:\n                await app.shutdown()\n            except Exception:\n                pass\n            return\n\n        self.sig_info.emit(f\"Webhook : {webhook_url} (port {port})\")\n        self.sig_info.emit(\"Bot Telegram démarré en mode webhook.\")\n        try:\n            if self._stop_evt:\n                await self._stop_evt.wait()\n        finally:\n            try:\n                await app.stop_webhook()\n            except Exception:\n                pass\n            try:\n                await app.stop()\n            except Exception:\n                pass\n            try:\n                await app.shutdown()\n            except Exception:\n                pass\n\n    def stop(self):\n        if self._loop and self._stop_evt:\n            self._loop.call_soon_threadsafe(self._stop_evt.set)\n# ---------------------- Utilitaires de fichiers ----------------------\n_RESERVED = '<>:\"/\\\\|?*'\n\n\ndef sanitize_filename(name: str) -> str:\n    \"\"\"Nettoie un nom de fichier pour le rendre compatible multiplateforme.\"\"\"\n    safe = \"\".join(\"_\" if ch in _RESERVED else ch for ch in name)\n    safe = re.sub(r\"\\s+\", \" \", safe).strip()\n    if len(safe) > 150:\n        safe = safe[:150].rstrip()\n    return safe or \"file\"\n\n\ndef _unique_path(dst: pathlib.Path) -> pathlib.Path:\n    \"\"\"\n    Retourne un chemin libre en ajoutant -1, -2, ... si 'dst' existe déjà.\n    \"\"\"\n    if not dst.exists():\n        return dst\n    stem, suffix = dst.stem, dst.suffix\n    i = 1\n    while True:\n        cand = dst.with_name(f\"{stem}-{i}{suffix}\")\n        if not cand.exists():\n            return cand\n        i += 1\n\n\ndef ensure_audio(task: Task) -> Optional[str]:\n    \"\"\"Garantit la présence d'un MP3 exploitable pour la transcription.\"\"\"\n\n    if task.final_audio_path and os.path.exists(task.final_audio_path):\n        return task.final_audio_path\n    if not task.final_video_path or not os.path.exists(task.final_video_path):\n        return None\n    if not shutil.which(\"ffmpeg\"):\n        return None\n\n    src = pathlib.Path(task.final_video_path)\n    base = src.stem\n    safe_base = sanitize_filename(base)\n    dst = _unique_path(AUDIOS_DIR / f\"{safe_base}.mp3\")\n\n    try:\n        proc = subprocess.run(\n            [\n                \"ffmpeg\",\n                \"-y\",\n                \"-i\",\n                str(src),\n                \"-vn\",\n                \"-acodec\",\n                \"libmp3lame\",\n                \"-b:a\",\n                \"192k\",\n                str(dst),\n            ],\n            capture_output=True,\n            text=True,\n        )\n        if proc.returncode == 0 and dst.exists():\n            task.final_audio_path = str(dst)\n            return task.final_audio_path\n    except Exception:\n        pass\n    return None\n\n\ndef themed_icon(*names: str) -> QIcon:\n    for name in names:\n        icon = QIcon.fromTheme(name)\n        if not icon.isNull():\n            return icon\n    return QIcon()\n\n\ndef _is_merge_in_progress(repo: pathlib.Path) -> bool:\n    return (repo / \".git\" / \"MERGE_HEAD\").exists()\n\n\ndef find_existing_outputs(video_id: str) -> dict:\n    \"\"\"Cherche des fichiers audio/vidéo déjà produits pour l'ID donné.\"\"\"\n    found = {\"audio\": None, \"video\": None}\n    if not video_id:\n        return found\n\n    token = f\"[{video_id}]\"\n\n    def _pick_latest(paths: list[pathlib.Path]) -> Optional[pathlib.Path]:\n        if not paths:\n            return None\n        try:\n            return max(paths, key=lambda p: p.stat().st_mtime)\n        except Exception:\n            return paths[0]\n\n    audio_exts = {\".mp3\", \".m4a\", \".wav\", \".ogg\", \".flac\"}\n    video_exts = {\".mp4\", \".mkv\", \".webm\", \".mov\"}\n\n    try:\n        audio_candidates = [\n            p for p in AUDIOS_DIR.glob(f\"*{token}*\")\n            if p.is_file() and p.suffix.lower() in audio_exts\n        ]\n        video_candidates = [\n            p for p in VIDEOS_DIR.glob(f\"*{token}*\")\n            if p.is_file() and p.suffix.lower() in video_exts\n        ]\n\n        audio_path = _pick_latest(audio_candidates)\n        video_path = _pick_latest(video_candidates)\n        if audio_path:\n            found[\"audio\"] = str(audio_path)\n        if video_path:\n            found[\"video\"] = str(video_path)\n    except Exception:\n        pass\n\n    return found\n\n\ndef move_final_outputs(task: Task) -> dict:\n    \"\"\"\n    Déplace les fichiers finaux (.mp4, .mp3) du sous-dossier 'Titre [ID]'\n    vers 'Videos' et 'Audios' (à plat). Gère les collisions de noms.\n    \"\"\"\n    moved = {\"audio\": None, \"video\": None}\n    if not task.video_id or not task.filename:\n        return moved\n\n    try:\n        src_dir = pathlib.Path(task.filename).parent\n        token = f\"[{task.video_id}]\"\n\n        for p in list(src_dir.glob(f\"*{token}*\")):\n            if not p.is_file():\n                continue\n            ext = p.suffix.lower()\n\n            # ⛔ 1) Ne PAS déplacer les flux audio bruts (intermédiaires)\n            if ext in {\".m4a\", \".aac\", \".wav\", \".ogg\", \".flac\"}:\n                continue\n\n            # ⛔ 2) Ne PAS déplacer les .mp4 intermédiaires (.fNNN.mp4)\n            if ext == \".mp4\" and \".f\" in p.stem:\n                continue\n\n            # ✅ 3) On ne s'occupe que des fichiers finaux utiles\n            if ext not in (\".mp4\", \".mp3\", \".mkv\", \".webm\", \".mov\"):\n                continue\n\n            stem = p.stem\n            token_segment = \"\"\n            if \"[\" in stem and \"]\" in stem:\n                start = stem.rfind(\"[\")\n                end = stem.rfind(\"]\")\n                if start >= 0 and end > start:\n                    token_segment = stem[start : end + 1]\n\n            # Dossier cible (audios vs vidéos)\n            if ext == \".mp3\":\n                base_dir = AUDIOS_DIR\n            else:\n                base_dir = VIDEOS_DIR\n\n            # Construction d'un nom sûr et stable\n            prefix = stem\n            if token_segment:\n                prefix = stem.replace(token_segment, \"\").strip()\n            safe_prefix = sanitize_filename(prefix)\n            if token_segment:\n                safe_stem = (safe_prefix + (\" \" if safe_prefix else \"\") + token_segment).strip()\n            else:\n                safe_stem = safe_prefix\n            safe_name = f\"{safe_stem}{ext}\"\n            dst = _unique_path(base_dir / safe_name)\n\n            try:\n                p.replace(dst)\n            except Exception:\n                shutil.move(str(p), str(dst))\n\n            if base_dir == VIDEOS_DIR:\n                moved[\"video\"] = str(dst)\n                task.final_video_path = str(dst)\n            else:\n                moved[\"audio\"] = str(dst)\n                task.final_audio_path = str(dst)\n    except Exception:\n        pass\n    return moved\n\n\ndef cleanup_orphans_in_outputs(task: Task):\n    \"\"\"Supprime des sorties finales les fichiers intermédiaires orphelins déjà déplacés par erreur.\"\"\"\n    if not task.video_id:\n        return\n    token = f\"[{task.video_id}]\"\n    try:\n        for p in AUDIOS_DIR.glob(f\"*{token}*\"):\n            if not p.is_file():\n                continue\n            ext = p.suffix.lower()\n            if ext == \".m4a\" or (ext == \".mp4\" and \".f\" in p.stem) or ext in {\".aac\", \".wav\", \".ogg\", \".flac\"}:\n                try:\n                    p.unlink()\n                except Exception:\n                    pass\n    except Exception:\n        pass\n\n\ndef delete_dir_if_empty(path: pathlib.Path):\n    \"\"\"\n    Supprime 'path' s'il est vide (ignore erreurs).\n    \"\"\"\n    try:\n        if path.is_dir():\n            # re-liste après les déplacements / nettoyages\n            if not any(path.iterdir()):\n                path.rmdir()\n    except Exception:\n        pass\n\n# ---------------------- Onglet YouTube ----------------------\n\nclass YoutubeTab(QWidget):\n    sig_request_transcription = Signal(list)\n    # chat_id peut dépasser la taille d'un int 32 bits -> utiliser \"object\"\n    sig_audio_completed = Signal(object, str)  # chat_id, audio_path\n\n    def __init__(self, app_ref, parent=None):\n        super().__init__(parent)\n        self.setAcceptDrops(True)\n        self.app_ref = app_ref\n        self.queue: List[Task] = []\n        self.current_worker: Optional[DownloadWorker] = None\n        self.last_inspect_info: Dict = {}\n        self.inspect_worker = None\n        self.inspect_seq = 0            # numéro de requête pour ignorer les réponses obsolètes\n        self.inspect_debounce = QTimer(self)\n        self.inspect_debounce.setSingleShot(True)\n        self.inspect_debounce.setInterval(250)  # 250ms de debounce\n        self.inspect_debounce.timeout.connect(self._inspect_current_after_debounce)\n        self.build_ui()\n\n    # PATCH START: helper curseur attente + usage\n    def _cursor_wait(self, on: bool):\n        if on and QApplication.overrideCursor() is None:\n            QApplication.setOverrideCursor(Qt.WaitCursor)\n        elif not on:\n            try:\n                QApplication.restoreOverrideCursor()\n            except Exception:\n                pass\n\n    def _open_dir(self, path: pathlib.Path):\n        try:\n            os.startfile(str(path))  # type: ignore[attr-defined]\n        except AttributeError:\n            QDesktopServices.openUrl(QUrl.fromLocalFile(str(path)))\n        except Exception as e:\n            QMessageBox.warning(self, \"Erreur\", f\"Impossible d’ouvrir le dossier : {e}\")\n    # PATCH END\n\n    def build_ui(self):\n        root = QVBoxLayout(self)\n        root.setContentsMargins(12, 12, 12, 12)\n        root.setSpacing(8)\n\n        # ----- URLs + Inspecteur -----\n        urls_box = QGroupBox(\"URLs\")\n        urls_layout = QVBoxLayout(urls_box)\n        urls_layout.setContentsMargins(12, 12, 12, 12)\n        urls_layout.setSpacing(8)\n\n        add_line = QHBoxLayout()\n        add_line.setSpacing(8)\n        self.edit_url = QLineEdit()\n        self.edit_url.setPlaceholderText(\"Colle une URL YouTube/playlist et presse Entrée pour l’ajouter\")\n        self.edit_url.returnPressed.connect(self.add_url)\n        btn_add = QPushButton(\"Ajouter\")\n        icon_add = themed_icon(\"list-add\", \"document-new\")\n        if not icon_add.isNull():\n            btn_add.setIcon(icon_add)\n        btn_add.clicked.connect(self.add_url)\n        btn_paste = QPushButton(\"Coller URL\")\n        icon_paste = themed_icon(\"edit-paste\")\n        if not icon_paste.isNull():\n            btn_paste.setIcon(icon_paste)\n        btn_paste.clicked.connect(self.paste_clipboard)\n        btn_file = QPushButton(\"Depuis .txt\")\n        icon_file = themed_icon(\"document-open\", \"text-x-generic\")\n        if not icon_file.isNull():\n            btn_file.setIcon(icon_file)\n        btn_file.clicked.connect(self.add_from_file)\n        btn_clear_urls = QPushButton(\"Vider la liste\")\n        icon_clear = themed_icon(\"edit-clear\", \"user-trash\")\n        if not icon_clear.isNull():\n            btn_clear_urls.setIcon(icon_clear)\n        btn_clear_urls.clicked.connect(self.clear_url_list)\n        btn_open = QPushButton(\"Ouvrir le dossier\")\n        icon_open = themed_icon(\"folder-open\")\n        if not icon_open.isNull():\n            btn_open.setIcon(icon_open)\n        btn_open.clicked.connect(self.open_output_dir)\n        btn_open_v = QPushButton(\"Ouvrir Vidéos\")\n        if not icon_open.isNull():\n            btn_open_v.setIcon(icon_open)\n        btn_open_v.clicked.connect(lambda: self._open_dir(VIDEOS_DIR))\n        btn_open_a = QPushButton(\"Ouvrir Audios\")\n        if not icon_open.isNull():\n            btn_open_a.setIcon(icon_open)\n        btn_open_a.clicked.connect(lambda: self._open_dir(AUDIOS_DIR))\n        add_line.addWidget(self.edit_url, 1)\n        add_line.addWidget(btn_add)\n        add_line.addWidget(btn_paste)\n        add_line.addWidget(btn_file)\n        add_line.addWidget(btn_clear_urls)\n        add_line.addWidget(btn_open)\n        add_line.addWidget(btn_open_v)\n        add_line.addWidget(btn_open_a)\n        urls_layout.addLayout(add_line)\n\n        self.list = QListWidget()\n        self.list.setContextMenuPolicy(Qt.ActionsContextMenu)\n        act_del = QAction(\"Supprimer la sélection\", self)\n        act_del.triggered.connect(self.delete_selected)\n        self.list.addAction(act_del)\n        self.list.currentItemChanged.connect(self.on_current_item_changed)\n        urls_layout.addWidget(self.list)\n\n        # Tableau formats\n        self.tbl = QTableWidget(0, 10)\n        self.tbl.setHorizontalHeaderLabels(\n            [\n                \"✔\",\n                \"ID video\",\n                \"Résolution\",\n                \"FPS\",\n                \"Ext/VC\",\n                \"Poids vidéo\",\n                \"ID audio\",\n                \"Audio\",\n                \"Poids audio\",\n                \"Total estimé\",\n            ]\n        )\n        self.tbl.setSelectionBehavior(QAbstractItemView.SelectRows)\n        self.tbl.setEditTriggers(QAbstractItemView.NoEditTriggers)\n        self.tbl.setSelectionMode(QAbstractItemView.SingleSelection)\n        self.tbl.horizontalHeader().setStretchLastSection(True)\n        self.tbl.itemDoubleClicked.connect(self.on_format_double_click)\n        urls_layout.addWidget(self.tbl)\n\n        # ----- Contrôles -----\n        ctrl = QHBoxLayout()\n        ctrl.setSpacing(8)\n        self.btn_start = QPushButton(\"Démarrer\")\n        icon_start = themed_icon(\"media-playback-start\", \"system-run\")\n        if not icon_start.isNull():\n            self.btn_start.setIcon(icon_start)\n        self.btn_start.clicked.connect(self.start_queue)\n        self.btn_stop = QPushButton(\"Stop\")\n        icon_stop = themed_icon(\"media-playback-stop\", \"process-stop\")\n        if not icon_stop.isNull():\n            self.btn_stop.setIcon(icon_stop)\n        self.btn_stop.clicked.connect(self.stop_current)\n        ctrl.addWidget(self.btn_start)\n        ctrl.addWidget(self.btn_stop)\n        ctrl.addStretch(1)\n        urls_layout.addLayout(ctrl)\n        root.addWidget(urls_box)\n\n        # ----- Statuts -----\n        stat_line = QHBoxLayout()\n        stat_line.setSpacing(8)\n        self.lab_name = QLabel(\"Fichier : —\")\n        self.lab_speed = QLabel(\"Vitesse : —\")\n        self.lab_size = QLabel(\"Taille : —\")\n        self.lab_eta = QLabel(\"ETA : —\")\n        stat_line.addWidget(self.lab_name, 3)\n        stat_line.addWidget(self.lab_speed, 1)\n        stat_line.addWidget(self.lab_size, 1)\n        stat_line.addWidget(self.lab_eta, 1)\n        root.addLayout(stat_line)\n\n        self.bar = QProgressBar()\n        self.bar.setRange(0, 100)\n        self.bar.setValue(0)\n        root.addWidget(self.bar)\n\n        self.setMinimumWidth(1080)\n\n    def open_output_dir(self):\n        path = OUT_DIR\n        self._open_dir(path)\n\n    def clear_url_list(self):\n        self.queue.clear()\n        self.list.clear()\n\n    def append_task(self, url: str):\n        t = Task(url=url)\n        self.queue.append(t)\n        item = QListWidgetItem(f\"[En attente] {url}\")\n        item.setData(Qt.UserRole, t)\n        self.list.addItem(item)\n        return item\n\n    def find_item_for_task(self, task: Task) -> Optional[QListWidgetItem]:\n        for idx in range(self.list.count()):\n            candidate = self.list.item(idx)\n            if candidate and candidate.data(Qt.UserRole) is task:\n                return candidate\n        return None\n\n    def _ensure_task_item(self, item: Optional[QListWidgetItem], task: Task) -> Optional[QListWidgetItem]:\n        if _is_list_item_valid(item):\n            return item\n        return self.find_item_for_task(task)\n\n    def add_url(self):\n        url = self.edit_url.text().strip()\n        if not url:\n            return\n        for i in range(self.list.count()):\n            exist_task: Task = self.list.item(i).data(Qt.UserRole)\n            if exist_task and exist_task.url == url:\n                QMessageBox.information(self, \"Déjà présent\", \"Cette URL est déjà dans la liste.\")\n                self.edit_url.clear()\n                return\n        item = self.append_task(url)\n        self.list.setCurrentItem(item)\n        self.inspect_task_async(item)\n        self.edit_url.clear()\n\n    def paste_clipboard(self):\n        cb = QApplication.clipboard()\n        if not cb:\n            return\n        text = (cb.text() or \"\").strip()\n        if not text:\n            return\n        match = YOUTUBE_REGEX.search(text)\n        if match:\n            self.edit_url.setText(match.group(1))\n            self.add_url()\n\n    def add_from_file(self):\n        p, _ = QFileDialog.getOpenFileName(self, \"Fichier .txt\", \"\", \"Text (*.txt)\")\n        if not p: return\n        new_items: List[QListWidgetItem] = []\n        for line in pathlib.Path(p).read_text(encoding=\"utf-8\").splitlines():\n            u = line.strip()\n            if not u: continue\n            exists = False\n            for i in range(self.list.count()):\n                exist_task: Task = self.list.item(i).data(Qt.UserRole)\n                if exist_task and exist_task.url == u:\n                    exists = True\n                    break\n            if exists:\n                continue\n            new_items.append(self.append_task(u))\n        if new_items:\n            item = new_items[0]\n            self.list.setCurrentItem(item)\n            self.inspect_task_async(item)\n\n    def dragEnterEvent(self, e):\n        if e.mimeData().hasUrls() or e.mimeData().hasText():\n            e.acceptProposedAction()\n\n    def dropEvent(self, e):\n        urls: list[str] = []\n        if e.mimeData().hasUrls():\n            for url in e.mimeData().urls():\n                path = url.toLocalFile() or url.toString()\n                if not path:\n                    continue\n                if path.lower().endswith(\".txt\"):\n                    try:\n                        for line in pathlib.Path(path).read_text(encoding=\"utf-8\").splitlines():\n                            if line.strip():\n                                urls.append(line.strip())\n                    except Exception:\n                        pass\n                else:\n                    urls.append(path)\n        if e.mimeData().hasText():\n            urls.append(e.mimeData().text())\n        for raw in urls:\n            if not raw:\n                continue\n            match = YOUTUBE_REGEX.search(raw.strip())\n            if match:\n                self.edit_url.setText(match.group(1))\n                self.add_url()\n        e.acceptProposedAction()\n\n    def delete_selected(self):\n        for it in self.list.selectedItems():\n            t: Task = it.data(Qt.UserRole)\n            if t in self.queue: self.queue.remove(t)\n            self.list.takeItem(self.list.row(it))\n\n    # ---------- Inspecteur ----------\n    def on_current_item_changed(self, current: QListWidgetItem, previous: QListWidgetItem):\n        # Debounce pour éviter de spammer l’inspect quand on navigue vite\n        self.inspect_debounce.start()\n\n    def _inspect_current_after_debounce(self):\n        item = self.list.currentItem()\n        if item:\n            self.inspect_task_async(item)\n\n    def inspect_task_async(self, item: QListWidgetItem):\n        \"\"\"Démarre l'inspection en arrière-plan pour l'item donné.\"\"\"\n        task: Task = item.data(Qt.UserRole)\n        if not task or not task.url:\n            return\n\n        # UI: état \"Analyse…\"\n        self.tbl.setRowCount(0)\n        self.statusBar(\"Analyse des formats…\")\n        self._cursor_wait(True)\n        self.btn_start.setEnabled(False)\n\n        # numéro de séquence pour ignorer les réponses tardives\n        self.inspect_seq += 1\n        seq = self.inspect_seq\n\n        # tuer le worker précédent s'il existe (on n'a pas d'annulation \"forte\" sur yt-dlp, mais on évite de mélanger les signaux)\n        if self.inspect_worker and self.inspect_worker.isRunning():\n            pass\n\n        w = InspectWorker(task.url, self)\n        self.inspect_worker = w\n        w.sig_done.connect(lambda url, info, s=seq: self.on_inspect_done(s, item, url, info))\n        w.sig_error.connect(lambda url, msg, s=seq: self.on_inspect_error(s, item, url, msg))\n        w.start()\n\n\n    def on_inspect_done(self, seq: int, item: QListWidgetItem, url: str, info: dict):\n        # ignorer si une requête plus récente a été lancée\n        if seq != self.inspect_seq:\n            return\n\n        self.last_inspect_info = info or {}\n        formats = self.last_inspect_info.get(\"formats\") or []\n        duration = self.last_inspect_info.get(\"duration\")\n\n        vlist = list_video_formats(formats, mp4_friendly=True)\n        abest = pick_best_audio(formats, mp4_friendly=True)\n\n        self.tbl.setRowCount(0)\n        task: Task = item.data(Qt.UserRole)\n\n        for vf in vlist:\n            vid_id = vf.get(\"format_id\") or \"\"\n            res = f\"{vf.get('height') or ''}p\"\n            fps = vf.get(\"fps\") or \"\"\n            vc = f\"{vf.get('ext','')}/{vf.get('vcodec','')}\"\n            vsize = estimate_size(vf, duration)\n\n            if abest:\n                aid = abest.get(\"format_id\") or \"\"\n                aname = f\"{abest.get('ext','')}/{abest.get('acodec','')}\"\n                asize = estimate_size(abest, duration)\n            else:\n                aid, aname, asize = \"\", \"\", None\n\n            total = (vsize or 0) + (asize or 0)\n\n            row = self.tbl.rowCount()\n            self.tbl.insertRow(row)\n\n            # Colonne 0 : point vert si format déjà choisi\n            chosen = f\"{vid_id}+{aid}\" if aid else vid_id\n            dot_item = QTableWidgetItem(\"●\" if task and task.selected_fmt == chosen else \"\")\n            dot_item.setTextAlignment(Qt.AlignCenter)\n            if dot_item.text():\n                dot_item.setForeground(QColor(0, 170, 0))\n            self.tbl.setItem(row, 0, dot_item)\n\n            values = [vid_id, res, str(fps), vc, human_size(vsize), aid, aname, human_size(asize), human_size(total)]\n            for col, val in enumerate(values, start=1):\n                self.tbl.setItem(row, col, QTableWidgetItem(val))\n\n        self.tbl.resizeColumnsToContents()\n        title = self.last_inspect_info.get(\"title\") or \"—\"\n        duration = self.last_inspect_info.get(\"duration\") or 0\n        dur_txt = human_eta(int(duration)) if duration else \"—\"\n        self.statusBar(f\"Formats prêts — {title} ({dur_txt})\")\n        self._cursor_wait(False)\n        self.btn_start.setEnabled(True)\n        self.inspect_worker = None\n\n\n    def on_inspect_error(self, seq: int, item: QListWidgetItem, url: str, msg: str):\n        # ignorer si une requête plus récente a été lancée\n        if seq != self.inspect_seq:\n            return\n        self._cursor_wait(False)\n        self.btn_start.setEnabled(True)\n        self.statusBar(\"Échec de l’analyse\")\n        QMessageBox.warning(self, \"Erreur\", f\"Impossible d’inspecter : {msg}\")\n        if \"429\" in msg or \"Too Many Requests\" in msg:\n            QMessageBox.warning(self, \"Limite atteinte\",\n                                \"YouTube a limité l’inspection (429). Réessaie dans ~1 minute.\")\n        self.inspect_worker = None\n\n    def on_format_double_click(self, it: QTableWidgetItem):\n        row = it.row()\n        item = self.list.currentItem()\n        if not item or row < 0:\n            return\n        task: Task = item.data(Qt.UserRole)\n        if not task:\n            return\n\n        vid_item = self.tbl.item(row, 1)\n        if not vid_item:\n            return\n        vid = vid_item.text().strip()\n        aid_item = self.tbl.item(row, 6)\n        aid = aid_item.text().strip() if aid_item else \"\"\n        chosen = f\"{vid}+{aid}\" if aid else vid\n        task.selected_fmt = chosen\n\n        for r in range(self.tbl.rowCount()):\n            di = self.tbl.item(r, 0)\n            if di is None:\n                di = QTableWidgetItem(\"\")\n                di.setTextAlignment(Qt.AlignCenter)\n                self.tbl.setItem(r, 0, di)\n            else:\n                di.setText(\"\")\n                di.setTextAlignment(Qt.AlignCenter)\n                di.setForeground(QColor())\n\n        ok = self.tbl.item(row, 0)\n        if ok is None:\n            ok = QTableWidgetItem(\"\")\n            self.tbl.setItem(row, 0, ok)\n        ok.setText(\"●\")\n        ok.setTextAlignment(Qt.AlignCenter)\n        ok.setForeground(QColor(0, 170, 0))\n\n        self.statusBar(f\"Format choisi : {chosen}\")\n\n    # ---------- Options yt-dlp ----------\n    def build_opts(self, task: Task):\n        outdir = OUT_DIR\n        fmt = task.selected_fmt or \"bestvideo[ext=mp4][vcodec*=avc1]+bestaudio[ext=m4a]/best[ext=mp4]\"\n\n        folder_tmpl = \"%(title).200s [%(id)s]\"\n        file_tmpl = \"%(title).200s [%(id)s].%(ext)s\"\n        outtmpl = str(outdir / folder_tmpl / file_tmpl)\n\n        opts = {\n            \"outtmpl\": outtmpl,\n            \"windowsfilenames\": True,\n            \"format\": fmt,\n            \"merge_output_format\": \"mp4\",\n            \"postprocessors\": [\n                {\"key\": \"FFmpegVideoRemuxer\", \"preferedformat\": \"mp4\"},\n                {\"key\": \"FFmpegExtractAudio\", \"preferredcodec\": \"mp3\", \"preferredquality\": \"192\"},\n            ],\n            # IMPORTANT: garder la vidéo après l'extraction audio\n            \"keepvideo\": True,\n            \"quiet\": True,\n            \"no_warnings\": True,\n            \"continuedl\": True,\n            \"concurrent_fragment_downloads\": 4,\n            \"noplaylist\": True,\n            \"download_archive\": str(DOWNLOAD_ARCHIVE),\n            \"nooverwrites\": True,\n            \"overwrites\": False,\n        }\n        return opts\n\n    # ---------- File d’attente ----------\n    def start_queue(self):\n        if self.list.count() == 0 and self.edit_url.text().strip():\n            self.add_url()\n\n        if self.current_worker and self.current_worker.isRunning():\n            QMessageBox.information(self, \"Déjà en cours\", \"Un téléchargement est déjà en cours.\")\n            return\n\n        # PATCH START: vérif FFmpeg\n        if not shutil.which(\"ffmpeg\") or not shutil.which(\"ffprobe\"):\n            QMessageBox.warning(\n                self,\n                \"FFmpeg manquant\",\n                \"Installe FFmpeg avant de télécharger (ex: winget install Gyan.FFmpeg).\",\n            )\n            return\n        # PATCH END\n\n        next_task = None\n        for i in range(self.list.count()):\n            it = self.list.item(i)\n            t: Task = it.data(Qt.UserRole)\n            if t.status in (\"En attente\", \"Erreur\"):\n                next_task = (i, it, t); break\n        if not next_task:\n            QMessageBox.information(self, \"Info\", \"Aucune tâche en attente.\")\n            return\n\n        _, item, task = next_task\n        task.status = \"En cours\"\n        safe_item = self._ensure_task_item(item, task)\n        if _is_list_item_valid(safe_item):\n            safe_item.setText(f\"[En cours] {task.url}\")\n\n        opts = self.build_opts(task)\n        self.current_worker = DownloadWorker(task, opts, self)\n        self.current_worker.sig_progress.connect(lambda d, tot, sp, eta, fn: self.on_progress(safe_item, task, d, tot, sp, eta, fn))\n        self.current_worker.sig_status.connect(self.statusBar)\n        self.current_worker.sig_done.connect(lambda ok, msg, info: self.on_done(safe_item, task, ok, msg, info))\n        self.btn_start.setEnabled(False)\n        self.current_worker.start()\n\n    def stop_current(self):\n        if self.current_worker and self.current_worker.isRunning():\n            self.current_worker.stop()\n\n    @Slot()\n    def on_progress(self, item: QListWidgetItem, task: Task, downloaded: int, total: int, speed: float, eta: int, filename: str):\n        task.downloaded, task.total, task.speed, task.eta = downloaded, total, speed, eta\n        if filename: task.filename = filename\n        pct = int(downloaded * 100 / total) if total else 0\n        self.bar.setValue(pct)\n        name = pathlib.Path(task.filename).name if task.filename else \"—\"\n        self.lab_name.setText(f\"Fichier : {name}\")\n        self.lab_speed.setText(f\"Vitesse : {human_rate(speed)}\")\n        self.lab_size.setText(f\"Taille : {human_size(downloaded)} / {human_size(total)}\")\n        self.lab_eta.setText(f\"ETA : {human_eta(eta)}\")\n        safe_item = self._ensure_task_item(item, task)\n        if _is_list_item_valid(safe_item):\n            safe_item.setText(f\"[{pct:>3}%] {task.url}\")\n\n    @Slot()\n    def on_done(self, item: QListWidgetItem, task: Task, ok: bool, msg: str, info: dict):\n        safe_item = self._ensure_task_item(item, task)\n        if ok:\n            task.status = \"Terminé\"\n            if _is_list_item_valid(safe_item):\n                safe_item.setText(f\"[Terminé] {task.url}\")\n            self.statusBar(f\"Terminé : {msg}\")\n            task.video_id = (info or {}).get(\"id\")\n            moved = move_final_outputs(task)\n            self.cleanup_residuals(task)\n            cleanup_orphans_in_outputs(task)\n            try:\n                if task.filename:\n                    subdir = OUT_DIR / pathlib.Path(task.filename).parent.name\n                    delete_dir_if_empty(subdir)\n            except Exception:\n                pass\n\n            audio_path = moved.get(\"audio\") or task.final_audio_path\n            if not audio_path:\n                audio_path = ensure_audio(task)\n                if audio_path:\n                    self.statusBar(\"Audio généré depuis la vidéo pour transcription\")\n            if task.source == \"telegram\" and task.chat_id and audio_path:\n                self.sig_audio_completed.emit(task.chat_id, audio_path)\n            elif audio_path:\n                reply = QMessageBox.question(\n                    self,\n                    \"Transcription\",\n                    \"Voulez-vous transcrire l’audio téléchargé ?\",\n                    QMessageBox.Yes | QMessageBox.No,\n                )\n                if reply == QMessageBox.Yes:\n                    self.sig_request_transcription.emit([audio_path])\n        else:\n            task.status = \"Erreur\"\n            if _is_list_item_valid(safe_item):\n                safe_item.setText(f\"[Erreur] {task.url}\")\n            if task.source == \"telegram\" and task.chat_id:\n                main = self.window()\n                worker = getattr(main, \"telegram_worker\", None)\n                if worker:\n                    worker.send_message(task.chat_id, f\"Échec du téléchargement : {msg}\")\n            else:\n                QMessageBox.warning(self, \"Erreur\", f\"Échec du téléchargement :\\n{msg}\")\n        self.bar.setValue(0)\n        self.current_worker = None\n        self.btn_start.setEnabled(True)\n        QTimer.singleShot(200, self.start_queue)\n        return\n\n    def statusBar(self, text: str):\n        self.window().setWindowTitle(f\"FlowGrab — {text}\")\n\n    def cleanup_residuals(self, task: Task):\n        \"\"\"\n        Supprime les fichiers intermédiaires dans le sous-dossier d'origine :\n          - flux bruts (.webm, .m4a, etc.)\n          - .fNNN.mp4 (vidéo intermédiaire)\n        Conserve:\n          - Titre [ID].mp4 (déjà déplacée)\n          - Titre [ID].mp3 (déjà déplacée)\n        \"\"\"\n        if not task.video_id or not task.filename:\n            return\n\n        subdir = pathlib.Path(task.filename).parent\n        if not subdir.exists():\n            return\n\n        token = f\"[{task.video_id}]\"\n        for p in list(subdir.iterdir()):\n            try:\n                if not p.is_file() or token not in p.name:\n                    continue\n                ext = p.suffix.lower()\n                # les finaux ont été déplacés; on ne touche qu'aux intermédiaires\n                if ext == \".mp4\":\n                    if \".f\" in p.stem:\n                        p.unlink()\n                    continue\n                if ext == \".mp3\":\n                    continue\n                p.unlink()\n            except Exception:\n                pass\n\n\nclass TikTokTab(YoutubeTab):\n    \"\"\"\n    Onglet TikTok : même logique que YoutubeTab, mais détection d'URL TikTok,\n    format par défaut adapté, et archive dédiée.\n    \"\"\"\n\n    def build_ui(self):\n        super().build_ui()\n        # Ajuster juste le placeholder d’entrée pour clarifier au user\n        self.edit_url.setPlaceholderText(\"Colle une URL TikTok et presse Entrée pour l’ajouter\")\n\n    # --- Détection d'URL (TikTok) ---\n    def add_url(self):\n        url = self.edit_url.text().strip()\n        if not url:\n            return\n        # Détection TikTok\n        m = TIKTOK_REGEX.search(url)\n        if not m:\n            QMessageBox.information(self, \"URL invalide\", \"Cette URL ne semble pas être une URL TikTok.\")\n            return\n        url = m.group(1)\n        # Éviter doublons\n        for i in range(self.list.count()):\n            exist_task: Task = self.list.item(i).data(Qt.UserRole)\n            if exist_task and exist_task.url == url:\n                QMessageBox.information(self, \"Déjà présent\", \"Cette URL est déjà dans la liste.\")\n                self.edit_url.clear()\n                return\n        item = self.append_task(url)\n        self.list.setCurrentItem(item)\n        self.inspect_task_async(item)\n        self.edit_url.clear()\n\n    def paste_clipboard(self):\n        cb = QApplication.clipboard()\n        if not cb:\n            return\n        text = (cb.text() or \"\").strip()\n        if not text:\n            return\n        match = TIKTOK_REGEX.search(text)\n        if match:\n            self.edit_url.setText(match.group(1))\n            self.add_url()\n\n    def dropEvent(self, e):\n        urls: list[str] = []\n        if e.mimeData().hasUrls():\n            for url in e.mimeData().urls():\n                path = url.toLocalFile() or url.toString()\n                if path:\n                    urls.append(path)\n        if e.mimeData().hasText():\n            urls.append(e.mimeData().text())\n        for raw in urls:\n            if not raw:\n                continue\n            match = TIKTOK_REGEX.search(raw.strip())\n            if match:\n                self.edit_url.setText(match.group(1))\n                self.add_url()\n        e.acceptProposedAction()\n\n    # --- Options yt-dlp spécifiques TikTok ---\n    def build_opts(self, task: Task):\n        outdir = OUT_DIR\n        # Sur TikTok, la vidéo arrive souvent déjà muxée (mp4); fallback \"best\"\n        fmt = task.selected_fmt or \"best[ext=mp4]/best\"\n\n        folder_tmpl = \"%(title).200s [%(id)s]\"\n        file_tmpl = \"%(title).200s [%(id)s].%(ext)s\"\n        outtmpl = str(outdir / folder_tmpl / file_tmpl)\n\n        opts = {\n            \"outtmpl\": outtmpl,\n            \"windowsfilenames\": True,\n            \"format\": fmt,\n            \"merge_output_format\": \"mp4\",\n            \"postprocessors\": [\n                {\"key\": \"FFmpegVideoRemuxer\", \"preferedformat\": \"mp4\"},\n                {\"key\": \"FFmpegExtractAudio\", \"preferredcodec\": \"mp3\", \"preferredquality\": \"192\"},\n            ],\n            \"keepvideo\": True,  # on garde la vidéo après extraction mp3\n            \"quiet\": True,\n            \"no_warnings\": True,\n            \"continuedl\": True,\n            \"concurrent_fragment_downloads\": 4,\n            \"noplaylist\": True,\n            \"download_archive\": str(DOWNLOAD_ARCHIVE_TT),  # archive séparée\n            \"nooverwrites\": True,\n            \"overwrites\": False,\n        }\n        return opts\n\n\nclass ServeurTab(QWidget):\n    \"\"\"Onglet très simple avec deux boutons : Allumer / Éteindre.\n    Allumer => lance PowerShell avec le script (cloudflared + n8n).\n    Éteindre => arrête le process et son arbre.\n    \"\"\"\n\n    sig_public_url = Signal(str)\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.worker: LongProcWorker | None = None\n        self.ps_file: str | None = None\n        self._pid: int | None = None\n        self._last_public_url: str | None = None\n        self.build_ui()\n\n    def build_ui(self):\n        root = QVBoxLayout(self)\n\n        # Ligne boutons + statut\n        row = QHBoxLayout()\n        self.btn_on = QPushButton(\"Allumer\")\n        self.btn_off = QPushButton(\"Éteindre\")\n        self.btn_off.setEnabled(False)\n        self.btn_open = QPushButton(\"Ouvrir n8n\")\n        self.btn_open.setEnabled(False)\n        self.lab_status = QLabel(\"Statut : inactif\")\n        self.btn_on.clicked.connect(self.start)\n        self.btn_off.clicked.connect(self.stop)\n        self.btn_open.clicked.connect(self.open_n8n)\n        row.addWidget(self.btn_on)\n        row.addWidget(self.btn_off)\n        row.addWidget(self.btn_open)\n        row.addStretch(1)\n        row.addWidget(self.lab_status)\n        root.addLayout(row)\n\n        # Logs\n        self.logs = QTextEdit()\n        self.logs.setReadOnly(True)\n        self.logs.setPlaceholderText(\"Logs cloudflared / n8n…\")\n        root.addWidget(self.logs)\n\n    # --- helpers UI ---\n    def log(self, s: str):\n        self.logs.append(s)\n        m = re.search(r\"https://[a-z0-9-]+\\.trycloudflare\\.com\", s)\n        if m:\n            url = m.group(0)\n            self._last_public_url = url\n            self.sig_public_url.emit(url)\n\n    def open_n8n(self):\n        url = self._last_public_url or \"http://localhost:5678\"\n        try:\n            QDesktopServices.openUrl(QUrl(url))\n        except Exception:\n            pass\n\n    # --- start/stop ---\n    def start(self):\n        if self.worker and self.worker.isRunning():\n            QMessageBox.information(self, \"Déjà en cours\", \"Le serveur est déjà allumé.\")\n            return\n\n        # Vérifs rapides côté Python pour retour immédiat à l'utilisateur\n        pwsh = shutil.which(\"powershell\") or shutil.which(\"powershell.exe\")\n        if not pwsh:\n            QMessageBox.warning(self, \"PowerShell introuvable\", \"PowerShell est requis.\")\n            return\n        if not shutil.which(\"cloudflared\"):\n            QMessageBox.warning(self, \"cloudflared introuvable\",\n                                \"Installe-le : winget install Cloudflare.cloudflared\")\n            return\n        if not shutil.which(\"n8n\"):\n            QMessageBox.warning(self, \"n8n introuvable\",\n                                \"Installe-le : npm i -g n8n\")\n            return\n\n        # Écrit le script PowerShell fourni par l'utilisateur dans un fichier temporaire\n        ps_code = r'''\nparam([int]$Port = 5678)\n\n$ErrorActionPreference = 'Stop'\n\n# --- Vérifs rapides\nif (-not (Get-Command cloudflared -ErrorAction SilentlyContinue)) {\n  Write-Error \"cloudflared introuvable. Installe-le: winget install Cloudflare.cloudflared\"\n  exit 1\n}\nif (-not (Get-Command n8n -ErrorAction SilentlyContinue)) {\n  Write-Error \"n8n introuvable. Installe-le: npm i -g n8n\"\n  exit 1\n}\nif (Get-NetTCPConnection -State Listen -LocalPort $Port -ErrorAction SilentlyContinue) {\n  Write-Error \"Le port $Port est déjà utilisé. Ferme l'autre instance ou choisis un autre port.\"\n  exit 1\n}\n\n# --- 1) Démarre cloudflared en arrière-plan et loggue sa sortie (stdout/err séparés)\n$logOut = Join-Path $env:TEMP \"cloudflared_n8n_${Port}_out.log\"\n$logErr = Join-Path $env:TEMP \"cloudflared_n8n_${Port}_err.log\"\nif (Test-Path $logOut) { Remove-Item $logOut -Force }\nif (Test-Path $logErr) { Remove-Item $logErr -Force }\n\n$cfArgs = @(\"tunnel\",\"--url\",\"http://localhost:$Port\",\"--ha-connections\",\"1\",\"--protocol\",\"quic\")\n$cfProc = Start-Process (Get-Command cloudflared).Source `\n          -ArgumentList $cfArgs -NoNewWindow `\n          -RedirectStandardOutput $logOut -RedirectStandardError $logErr -PassThru\nWrite-Host \"cloudflared PID: $($cfProc.Id). Attente de l'URL publique…\"\n\n# --- 2) Récupère l'URL publique\n$publicUrl = $null\n$regex = [regex]'https://[a-z0-9-]+\\.trycloudflare\\.com'\nfor ($i=0; $i -lt 60; $i++) {  # ~30s max\n  $content = \"\"\n  if (Test-Path $logOut) { $content += (Get-Content $logOut -Raw) }\n  if (Test-Path $logErr) { $content += \"`n\" + (Get-Content $logErr -Raw) }\n  if ($content) {\n    $m = $regex.Match($content)\n    if ($m.Success) { $publicUrl = $m.Value; break }\n  }\n  Start-Sleep -Milliseconds 500\n}\n\nif ($publicUrl) {\n  Write-Host \"URL publique: $publicUrl\"\n  $env:WEBHOOK_URL         = $publicUrl\n  $env:N8N_EDITOR_BASE_URL = $publicUrl\n} else {\n  Write-Warning \"Impossible de lire l'URL publique. n8n sera accessible en local uniquement.\"\n}\n\n# --- 3) Exporte le port (ne PAS changer N8N_ENCRYPTION_KEY si tu as déjà lancé n8n avant)\n$env:N8N_PORT = \"$Port\"\n\n# --- 4) Lance n8n au premier plan\nWrite-Host \"Démarrage n8n sur http://localhost:$Port ...\"\n& (Get-Command n8n).Source\n\n# --- 5) A l'arrêt de n8n, coupe cloudflared proprement\nWrite-Host \"n8n arrêté. Extinction de cloudflared…\"\nif ($cfProc -and -not $cfProc.HasExited) {\n  try { Stop-Process -Id $cfProc.Id -Force -ErrorAction SilentlyContinue } catch {}\n}\nWrite-Host \"Terminé.\"\n'''\n        if self.ps_file and os.path.exists(self.ps_file):\n            try:\n                os.remove(self.ps_file)\n            except Exception:\n                pass\n            self.ps_file = None\n        fd, tmp = tempfile.mkstemp(prefix=\"fg_srv_\", suffix=\".ps1\")\n        os.close(fd)\n        with open(tmp, \"w\", encoding=\"utf-8\") as f:\n            f.write(ps_code)\n        self.ps_file = tmp\n\n        args = [\n            pwsh,\n            \"-NoProfile\", \"-ExecutionPolicy\", \"Bypass\",\n            \"-File\", tmp,\n            \"-Port\", \"5678\",  # le besoin: 2 boutons sans autre option; port fixe\n        ]\n\n        self.log(f\">>> Lancement serveur (port 5678)\")\n        self.lab_status.setText(\"Statut : démarrage…\")\n        self.btn_on.setEnabled(False)\n        self.btn_off.setEnabled(True)\n        self.btn_open.setEnabled(False)\n\n        self.worker = LongProcWorker(args, env=os.environ.copy(), parent=self)\n        self.worker.sig_started.connect(self.on_started)\n        self.worker.sig_line.connect(self.log)\n        self.worker.sig_done.connect(self.on_done)\n        self.worker.start()\n\n    def on_started(self, pid: int):\n        self._pid = pid\n        self.lab_status.setText(f\"Statut : en cours (pid {pid})\")\n        self.log(f\"[ps] démarré (pid {pid})\")\n        self.btn_open.setEnabled(True)\n\n    def stop(self):\n        self.lab_status.setText(\"Statut : arrêt…\")\n        self.log(\">>> Extinction demandée…\")\n        self.btn_open.setEnabled(False)\n        self._last_public_url = None\n        if self.worker and self.worker.isRunning():\n            self.worker.stop()\n        else:\n            self.on_done(0)\n\n    def on_done(self, code: int):\n        self.log(f\">>> Terminé (code={code})\")\n        self.lab_status.setText(\"Statut : inactif\")\n        self.btn_on.setEnabled(True)\n        self.btn_off.setEnabled(False)\n        self.btn_open.setEnabled(False)\n        self._last_public_url = None\n        self._pid = None\n        self.worker = None\n        if self.ps_file:\n            try:\n                os.remove(self.ps_file)\n            except Exception:\n                pass\n            self.ps_file = None\n\n\n# ---------------------- Onglet Transcription ----------------------\nclass MultiUploadWorker(QThread):\n    sig_log = Signal(str)\n    sig_done = Signal(bool)\n\n    def __init__(self, url: str, files: List[str], parent=None):\n        super().__init__(parent)\n        self.url = url\n        self.files = list(files)\n\n    def run(self):\n        try:\n            import requests\n        except ImportError:\n            self.sig_log.emit(\"Erreur : le module 'requests' est introuvable. Exécute `pip install requests`.\")\n            self.sig_done.emit(False)\n            return\n\n        if not self.files:\n            self.sig_log.emit(\"Aucun fichier à envoyer.\")\n            self.sig_done.emit(False)\n            return\n\n        all_ok = True\n        self.sig_log.emit(f\">>> Envoi vers {self.url} — {len(self.files)} fichier(s)\")\n        session = requests.Session()\n        for path in self.files:\n            if not os.path.exists(path):\n                self.sig_log.emit(f\"[SKIP] Introuvable : {path}\")\n                all_ok = False\n                continue\n\n            mime, _ = mimetypes.guess_type(path)\n            mime = mime or \"application/octet-stream\"\n            basename = os.path.basename(path)\n            self.sig_log.emit(\n                f\"POST {self.url}\\n  -> {basename} (MIME={mime}) field='data'\"\n            )\n\n            try:\n                with open(path, \"rb\") as handle:\n                    files = {\"data\": (basename, handle, mime)}\n                    resp = session.post(self.url, files=files, timeout=(10, 600))\n                self.sig_log.emit(f\"HTTP {resp.status_code}\")\n                body = resp.text or \"\"\n                if len(body) > 2000:\n                    body = body[:2000] + \"\\n...[tronqué]...\"\n                if body.strip():\n                    self.sig_log.emit(body)\n                body_lower = body.lower()\n                if resp.status_code == 404 and (\n                    \"not registered\" in body_lower or \"did you mean get\" in body_lower\n                ):\n                    self.sig_log.emit(\n                        \"Indice : sur un webhook-test, clique sur 'Listen for test event' avant d'envoyer.\"\n                    )\n                if not (200 <= resp.status_code < 300):\n                    all_ok = False\n            except Exception as exc:\n                all_ok = False\n                self.sig_log.emit(f\"[ERREUR réseau] {exc}\")\n\n        session.close()\n        self.sig_log.emit(\">>> Terminé.\")\n        self.sig_done.emit(all_ok)\n\n\nclass TranscriptionTab(QWidget):\n    sig_url_changed = Signal(str)\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.setAcceptDrops(True)\n        self.selected_paths: set[str] = set()\n        self.worker: MultiUploadWorker | None = None\n        self.last_dir: str | None = None\n        self._updating_url = False\n        self._webhook_path = \"/webhook/Audio\"\n        self.build_ui()\n        self.update_send_button()\n\n    # PATCH START: rename N8NTab -> TranscriptionTab (+ libellés)\n    def build_ui(self):\n        root = QVBoxLayout(self)\n        root.setContentsMargins(12, 12, 12, 12)\n        root.setSpacing(8)\n\n        url_row = QHBoxLayout()\n        url_row.setSpacing(8)\n        url_row.addWidget(QLabel(\"URL de transcription (n8n):\"))\n        self.edit_url = QLineEdit()\n        self.edit_url.setPlaceholderText(\"https://…trycloudflare.com/webhook/Audio\")\n        self.edit_url.textChanged.connect(self.on_url_changed)\n        url_row.addWidget(self.edit_url, 1)\n        root.addLayout(url_row)\n\n        actions_row = QHBoxLayout()\n        actions_row.setSpacing(8)\n        self.btn_add = QPushButton(\"Ajouter fichier(s)…\")\n        icon_add = themed_icon(\"list-add\", \"document-open\")\n        if not icon_add.isNull():\n            self.btn_add.setIcon(icon_add)\n        self.btn_add.clicked.connect(self.on_add_files)\n        self.btn_send = QPushButton()\n        icon_send = themed_icon(\"mail-send\", \"document-send\")\n        if not icon_send.isNull():\n            self.btn_send.setIcon(icon_send)\n        self.btn_send.clicked.connect(self.on_send)\n        self.btn_clear = QPushButton(\"Vider la liste\")\n        icon_clear = themed_icon(\"edit-clear\", \"user-trash\")\n        if not icon_clear.isNull():\n            self.btn_clear.setIcon(icon_clear)\n        self.btn_clear.clicked.connect(self.clear_selection_and_logs)\n        actions_row.addWidget(self.btn_add)\n        actions_row.addWidget(self.btn_send)\n        actions_row.addWidget(self.btn_clear)\n        actions_row.addStretch(1)\n        root.addLayout(actions_row)\n\n        self.list_sel = QListWidget()\n        self.list_sel.itemDoubleClicked.connect(self.remove_selected_item)\n        root.addWidget(self.list_sel, 1)\n\n        self.logs = QTextEdit()\n        self.logs.setReadOnly(True)\n        self.logs.setPlaceholderText(\"Logs webhook / réponses serveur…\")\n        root.addWidget(self.logs, 1)\n\n        self.setMinimumSize(720, 480)\n    # PATCH END\n\n    # --- sélection ---\n    def update_send_button(self):\n        count = len(self.selected_paths)\n        self.btn_send.setText(f\"Envoyer ({count})\")\n        self.btn_send.setEnabled(count > 0 and self.worker is None)\n\n    def add_to_selection(self, path: str):\n        norm = os.path.abspath(path)\n        if norm in self.selected_paths:\n            return\n        self.selected_paths.add(norm)\n        item = QListWidgetItem(os.path.basename(norm) or norm)\n        item.setToolTip(norm)\n        item.setData(Qt.UserRole, norm)\n        self.list_sel.addItem(item)\n        self.update_send_button()\n\n    def remove_selected_item(self, item: QListWidgetItem):\n        path = item.data(Qt.UserRole)\n        if path in self.selected_paths:\n            self.selected_paths.remove(path)\n        row = self.list_sel.row(item)\n        self.list_sel.takeItem(row)\n        self.update_send_button()\n\n    def dragEnterEvent(self, e):\n        if e.mimeData().hasUrls():\n            e.acceptProposedAction()\n\n    def dropEvent(self, e):\n        if not e.mimeData().hasUrls():\n            return\n        exts = {\".mp3\", \".m4a\", \".wav\", \".aac\", \".ogg\", \".flac\", \".mp4\", \".mkv\", \".webm\"}\n        for url in e.mimeData().urls():\n            path = url.toLocalFile()\n            if path and os.path.isfile(path):\n                if os.path.splitext(path)[1].lower() in exts:\n                    self.add_to_selection(path)\n        self.update_send_button()\n        e.acceptProposedAction()\n\n    def on_add_files(self):\n        start_dir = self.last_dir or str(pathlib.Path.home())\n        files, _ = QFileDialog.getOpenFileNames(\n            self,\n            \"Choisir des fichiers\",\n            start_dir,\n            \"Audio/Video (*.mp3 *.m4a *.wav *.aac *.ogg *.flac *.mp4 *.mkv *.webm);;Tous les fichiers (*.*)\",\n        )\n        if not files:\n            return\n        for path in files:\n            self.add_to_selection(path)\n        self.last_dir = os.path.dirname(files[-1]) or self.last_dir\n\n    # --- envoi ---\n    def on_send(self):\n        if self.worker is not None:\n            QMessageBox.information(self, \"Envoi en cours\", \"Un upload est déjà en cours.\")\n            return\n\n        url = (self.edit_url.text() or \"\").strip()\n        if not url:\n            QMessageBox.warning(self, \"Manque URL\", \"Colle l’URL du webhook n8n.\")\n            return\n\n        if not self.selected_paths:\n            QMessageBox.information(self, \"Rien à envoyer\", \"Sélectionne au moins un fichier.\")\n            return\n\n        files: List[str] = []\n        for idx in range(self.list_sel.count()):\n            item = self.list_sel.item(idx)\n            path = item.data(Qt.UserRole)\n            if path:\n                files.append(path)\n\n        if not files:\n            QMessageBox.information(self, \"Rien à envoyer\", \"Sélectionne au moins un fichier.\")\n            return\n\n        self.btn_send.setEnabled(False)\n        self.worker = MultiUploadWorker(url, files, self)\n        self.worker.sig_log.connect(self.logs.append)\n        self.worker.sig_done.connect(self.on_sent_done)\n        self.worker.start()\n        token = os.environ.get(\"FG_NOTIFY_TOKEN\", \"change_me\")\n        self.logs.append(\"Exemple n8n → App : GET http://127.0.0.1:5050/notify-done?token=<FG_NOTIFY_TOKEN>\")\n        if token == \"change_me\":\n            self.logs.append(\"Définis FG_NOTIFY_TOKEN dans tes variables d’environnement pour sécuriser la notification locale.\")\n\n    def on_sent_done(self, ok: bool):\n        self.worker = None\n        self.update_send_button()\n        if ok:\n            QMessageBox.information(self, \"OK\", \"Tous les envois ont réussi.\")\n        else:\n            QMessageBox.warning(\n                self,\n                \"Terminé avec erreurs\",\n                \"Au moins un fichier a échoué. Consulte les logs pour les détails.\",\n            )\n\n    def clear_selection_and_logs(self):\n        self.selected_paths.clear()\n        self.list_sel.clear()\n        self.logs.clear()\n        self.update_send_button()\n\n    # PATCH START: init + setters + envoi direct\n    def init_from_config(self, cfg: dict):\n        path = cfg.get(\"webhook_path\") or \"/webhook/Audio\"\n        full = cfg.get(\"webhook_full\") or \"\"\n        base = cfg.get(\"webhook_base\") or \"\"\n        if not full and base:\n            full = base.rstrip(\"/\") + path\n        if full:\n            self._set_url_text(full)\n        self._webhook_path = path\n\n    def set_webhook_full(self, full: str):\n        cur = (self.edit_url.text() or \"\").strip()\n        if not cur or \"trycloudflare.com\" in cur:\n            self._set_url_text(full)\n\n    def send_files_immediately(self, paths: list[str]):\n        for p in paths:\n            self.add_to_selection(p)\n        if self.worker is None:\n            self.on_send()\n        else:\n            self.logs.append(\"Upload déjà en cours, les fichiers sont ajoutés à la file.\")\n    # PATCH END\n\n    def _set_url_text(self, text: str):\n        self._updating_url = True\n        try:\n            self.edit_url.setText(text)\n        finally:\n            self._updating_url = False\n\n    def on_url_changed(self, text: str):\n        if self._updating_url:\n            return\n        self.sig_url_changed.emit(text)\n# ---------------------- Onglets placeholders ----------------------\nclass ComingSoonTab(QWidget):\n    def __init__(self, title=\"À venir\", parent=None):\n        super().__init__(parent)\n        lay = QVBoxLayout(self)\n        lbl = QLabel(f\"{title}\\n\\nBientôt disponible…\")\n        lbl.setAlignment(Qt.AlignCenter)\n        lay.addWidget(lbl)\n\nclass SettingsTab(QWidget):\n    \"\"\"\n    Onglet Paramètres généraux :\n    - Contrôle du thème\n    - Section Telegram (token, mode, démarrage)\n    - Outils de maintenance (git pull, redémarrage)\n    \"\"\"\n\n    def __init__(self, app_ref=None, parent=None):\n        super().__init__(parent)\n        self.app_ref = app_ref\n        self.worker: CommandWorker | None = None\n        self._loading_cfg = False\n        self.build_ui()\n\n    def build_ui(self):\n        root = QVBoxLayout(self)\n        root.setContentsMargins(12, 12, 12, 12)\n        root.setSpacing(8)\n\n        theme_line = QHBoxLayout()\n        theme_line.setSpacing(8)\n        theme_label = QLabel(\"Thème\")\n        self.cmb_theme = QComboBox()\n        self.cmb_theme.addItems([\"Clair\", \"Sombre\"])\n        self.cmb_theme.currentIndexChanged.connect(self.on_theme_change)\n        theme_line.addWidget(theme_label)\n        theme_line.addWidget(self.cmb_theme)\n        theme_line.addStretch(1)\n        root.addLayout(theme_line)\n        self.cmb_theme.setCurrentText(\"Sombre\")\n        theme_label.setVisible(False)\n        theme_label.setEnabled(False)\n        self.cmb_theme.setVisible(False)\n        self.cmb_theme.setEnabled(False)\n\n        # Section Telegram\n        grp_tg = QGroupBox(\"Telegram\")\n        tg_layout = QVBoxLayout(grp_tg)\n        tg_layout.setContentsMargins(12, 12, 12, 12)\n        tg_layout.setSpacing(8)\n\n        row_token = QHBoxLayout()\n        row_token.setSpacing(8)\n        row_token.addWidget(QLabel(\"Token\"))\n        self.ed_token = QLineEdit()\n        self.ed_token.setPlaceholderText(\"123456:ABC-DEF…\")\n        row_token.addWidget(self.ed_token, 1)\n        tg_layout.addLayout(row_token)\n\n        row_mode = QHBoxLayout()\n        row_mode.setSpacing(8)\n        self.lbl_mode = QLabel(\"Mode\")\n        row_mode.addWidget(self.lbl_mode)\n        self.cmb_mode = QComboBox()\n        self.cmb_mode.addItems([\"Polling\"])\n        self.cmb_mode.setCurrentText(\"Polling\")\n        row_mode.addWidget(self.cmb_mode)\n        self.lbl_port = QLabel(\"Port\")\n        row_mode.addWidget(self.lbl_port)\n        self.spin_port = QSpinBox()\n        self.spin_port.setRange(1, 65535)\n        self.spin_port.setValue(8081)\n        row_mode.addWidget(self.spin_port)\n        row_mode.addStretch(1)\n        tg_layout.addLayout(row_mode)\n\n        self.lbl_mode.setVisible(False)\n        self.lbl_mode.setEnabled(False)\n        self.cmb_mode.setVisible(False)\n        self.cmb_mode.setEnabled(False)\n        self.lbl_port.setVisible(False)\n        self.lbl_port.setEnabled(False)\n        self.spin_port.setVisible(False)\n        self.spin_port.setEnabled(False)\n\n        row_browser = QHBoxLayout()\n        row_browser.setSpacing(8)\n        self.lbl_browser_cookies = QLabel(\"Source cookies\")\n        row_browser.addWidget(self.lbl_browser_cookies)\n        self.cmb_browser_cookies = QComboBox()\n        self._browser_combo_values: list[tuple[str, str]] = [\n            (\"Auto (fallback)\", \"auto\"),\n            (\"Edge\", \"edge\"),\n            (\"Chrome\", \"chrome\"),\n            (\"Firefox\", \"firefox\"),\n            (\"Brave\", \"brave\"),\n            (\"Vivaldi\", \"vivaldi\"),\n            (\"Opera\", \"opera\"),\n            (\"Chromium\", \"chromium\"),\n            (\"cookies.txt\", \"cookiefile\"),\n            (\"Aucun (sans cookies)\", \"none\"),\n        ]\n        for label, value in self._browser_combo_values:\n            self.cmb_browser_cookies.addItem(label, value)\n        row_browser.addWidget(self.cmb_browser_cookies, 1)\n        row_browser.addStretch(1)\n        tg_layout.addLayout(row_browser)\n\n        row_cookies = QHBoxLayout()\n        row_cookies.setSpacing(8)\n        self.lbl_cookies = QLabel(\"Cookies.txt\")\n        row_cookies.addWidget(self.lbl_cookies)\n        self.ed_cookies = QLineEdit()\n        self.ed_cookies.setPlaceholderText(\"Chemin vers cookies.txt (optionnel)\")\n        row_cookies.addWidget(self.ed_cookies, 1)\n        self.btn_cookies = QPushButton(\"Parcourir…\")\n        icon_file = themed_icon(\"document-open\", \"folder-open\")\n        if not icon_file.isNull():\n            self.btn_cookies.setIcon(icon_file)\n        self.btn_cookies.clicked.connect(self.on_pick_cookies)\n        row_cookies.addWidget(self.btn_cookies)\n        tg_layout.addLayout(row_cookies)\n\n        row_user_agent = QHBoxLayout()\n        row_user_agent.setSpacing(8)\n        self.lbl_user_agent = QLabel(\"User-Agent\")\n        row_user_agent.addWidget(self.lbl_user_agent)\n        self.ed_user_agent = QLineEdit()\n        self.ed_user_agent.setPlaceholderText(\"Mozilla/5.0 …\")\n        row_user_agent.addWidget(self.ed_user_agent, 1)\n        tg_layout.addLayout(row_user_agent)\n\n        row_ctrl = QHBoxLayout()\n        row_ctrl.setSpacing(8)\n        self.btn_tg_start = QPushButton(\"Démarrer bot\")\n        icon_start = themed_icon(\"media-playback-start\", \"system-run\")\n        if not icon_start.isNull():\n            self.btn_tg_start.setIcon(icon_start)\n        self.btn_tg_stop = QPushButton(\"Arrêter bot\")\n        icon_stop = themed_icon(\"media-playback-stop\", \"process-stop\")\n        if not icon_stop.isNull():\n            self.btn_tg_stop.setIcon(icon_stop)\n        self.btn_tg_stop.setEnabled(False)\n        self.lab_tg = QLabel(\"Bot : inactif\")\n        row_ctrl.addWidget(self.btn_tg_start)\n        row_ctrl.addWidget(self.btn_tg_stop)\n        row_ctrl.addStretch(1)\n        row_ctrl.addWidget(self.lab_tg)\n        tg_layout.addLayout(row_ctrl)\n\n        root.addWidget(grp_tg)\n\n        # Ligne boutons maintenance\n        line = QHBoxLayout()\n        line.setSpacing(8)\n        self.btn_update = QPushButton(\"Mettre à jour l’app (redémarrage auto)\")\n        icon_update = themed_icon(\"view-refresh\", \"system-software-update\")\n        if not icon_update.isNull():\n            self.btn_update.setIcon(icon_update)\n        self.btn_restart = QPushButton(\"Redémarrer l’app\")\n        icon_restart = themed_icon(\"system-reboot\", \"application-exit\")\n        if not icon_restart.isNull():\n            self.btn_restart.setIcon(icon_restart)\n        self.btn_update.clicked.connect(self.on_update_clicked)\n        self.btn_restart.clicked.connect(self.on_restart_clicked)\n        line.addWidget(self.btn_update)\n        line.addWidget(self.btn_restart)\n        root.addLayout(line)\n\n        self.lab_git_hint = QLabel(\"\")\n        self.lab_git_hint.setWordWrap(True)\n        root.addWidget(self.lab_git_hint)\n\n        git_grp = QGroupBox(\"Git – Outils de merge\")\n        self.git_grp = git_grp\n        git_layout = QHBoxLayout(git_grp)\n        git_layout.setContentsMargins(12, 12, 12, 12)\n        git_layout.setSpacing(8)\n        self.btn_git_continue = QPushButton(\"Continuer le merge (guidé)\")\n        self.btn_git_continue.clicked.connect(self.on_git_continue_merge)\n        self.btn_git_abort = QPushButton(\"Abort merge (git merge --abort)\")\n        self.btn_git_abort.clicked.connect(self.on_git_merge_abort)\n        self.btn_git_stash_pull = QPushButton(\"Stash & Pull (rebase)\")\n        self.btn_git_stash_pull.clicked.connect(self.on_git_stash_pull)\n        git_layout.addWidget(self.btn_git_continue)\n        git_layout.addWidget(self.btn_git_abort)\n        git_layout.addWidget(self.btn_git_stash_pull)\n        root.addWidget(git_grp)\n        self.git_grp.setVisible(False)\n\n        # Zone de logs\n        self.logs = QTextEdit()\n        self.logs.setReadOnly(True)\n        self.logs.setPlaceholderText(\"Logs des opérations (git, Telegram, etc.)...\")\n        root.addWidget(self.logs)\n\n        # Info\n        info = QLabel(\"Astuce : l’app cherchera la racine du dépôt (.git) en remontant depuis le dossier du script.\")\n        info.setWordWrap(True)\n        root.addWidget(info)\n\n        # Connexions config Telegram / yt-dlp\n        self.ed_token.textChanged.connect(lambda s: self._save_cfg(\"telegram_token\", s.strip()))\n        self.cmb_mode.currentTextChanged.connect(lambda t: self._save_cfg(\"telegram_mode\", (t or \"auto\").lower()))\n        self.spin_port.valueChanged.connect(lambda v: self._save_cfg(\"telegram_port\", int(v)))\n        self.ed_cookies.textChanged.connect(lambda s: self._save_cfg(\"cookies_path\", s.strip()))\n        self.ed_user_agent.textChanged.connect(lambda s: self._save_cfg(\"user_agent\", s.strip()))\n        self.cmb_browser_cookies.currentIndexChanged.connect(self.on_browser_choice_changed)\n\n        self._update_cookie_inputs_state(\"auto\")\n        self.refresh_merge_state()\n\n    def init_from_config(self, cfg: dict):\n        self._loading_cfg = True\n        try:\n            token = cfg.get(\"telegram_token\") or \"\"\n            self.ed_token.setText(token)\n            self.cmb_mode.setCurrentText(\"Polling\")\n            port = int(cfg.get(\"telegram_port\") or DEFAULT_CONFIG[\"telegram_port\"])\n            self.spin_port.setValue(port)\n            cookies_path = cfg.get(\"cookies_path\") or \"\"\n            self.ed_cookies.setText(cookies_path)\n            user_agent = cfg.get(\"user_agent\") or DEFAULT_CONFIG[\"user_agent\"]\n            self.ed_user_agent.setText(user_agent)\n            browser_pref = (cfg.get(\"browser_cookies\") or \"auto\").strip().lower()\n            idx = self.cmb_browser_cookies.findData(browser_pref)\n            if idx < 0:\n                idx = 0\n            self.cmb_browser_cookies.setCurrentIndex(idx)\n            current_mode = self.cmb_browser_cookies.currentData(Qt.UserRole) or \"auto\"\n            self._update_cookie_inputs_state(str(current_mode))\n            self.set_telegram_idle()\n        finally:\n            self._loading_cfg = False\n        self.refresh_merge_state()\n\n    def _save_cfg(self, key: str, value: Any):\n        if self._loading_cfg or not self.app_ref:\n            return\n        cfg = self.app_ref.app_config\n        if key == \"telegram_token\":\n            cfg[key] = value or \"\"\n        elif key == \"telegram_mode\":\n            cfg[key] = value or \"polling\"\n        elif key == \"telegram_port\":\n            cfg[key] = int(value)\n        elif key == \"cookies_path\":\n            cfg[key] = value or \"\"\n        elif key == \"user_agent\":\n            cfg[key] = value or \"\"\n        elif key == \"browser_cookies\":\n            cfg[key] = value or \"auto\"\n        else:\n            cfg[key] = value\n        save_config(cfg)\n\n    def on_browser_choice_changed(self):\n        mode = self.cmb_browser_cookies.currentData(Qt.UserRole) or \"auto\"\n        self._update_cookie_inputs_state(str(mode))\n        if self._loading_cfg:\n            return\n        self._save_cfg(\"browser_cookies\", str(mode))\n\n    def _update_cookie_inputs_state(self, mode: str) -> None:\n        enable_cookie_file = mode == \"cookiefile\"\n        for widget in (self.lbl_cookies, self.ed_cookies, self.btn_cookies):\n            widget.setEnabled(enable_cookie_file)\n        # garder les champs visibles mais verrouillés si non pertinents\n        self.ed_cookies.setReadOnly(not enable_cookie_file)\n\n    def set_telegram_running(self, mode: str):\n        self.lab_tg.setText(f\"Bot : en cours ({mode})\")\n        self.btn_tg_start.setEnabled(False)\n        self.btn_tg_stop.setEnabled(True)\n\n    def set_telegram_idle(self):\n        self.lab_tg.setText(\"Bot : inactif\")\n        self.btn_tg_start.setEnabled(True)\n        self.btn_tg_stop.setEnabled(False)\n\n    def append_telegram_info(self, text: str):\n        self.append_log(f\"[Telegram] {text}\")\n\n    def on_pick_cookies(self):\n        path, _ = QFileDialog.getOpenFileName(self, \"Cookies.txt\", \"\", \"Text (*.txt);;Tous les fichiers (*.*)\")\n        if path:\n            self.ed_cookies.setText(path)\n\n    def refresh_merge_state(self):\n        repo = self.find_git_root()\n        in_merge = bool(repo and _is_merge_in_progress(repo))\n        if in_merge:\n            self.lab_git_hint.setText(\"Merge en cours détecté. Utilise les outils ci-dessous pour le résoudre.\")\n            self.btn_update.setEnabled(False)\n        else:\n            self.lab_git_hint.setText(\"\")\n            if not (self.worker and self.worker.isRunning()):\n                self.btn_update.setEnabled(True)\n\n    def _launch_git(self, args: list[str], cwd: pathlib.Path, next_cb: Callable[[int], None] | None = None) -> bool:\n        if self.worker and self.worker.isRunning():\n            QMessageBox.information(self, \"Git\", \"Une commande git est déjà en cours.\")\n            return False\n        git = shutil.which(\"git\")\n        if not git:\n            QMessageBox.warning(self, \"Git\", \"Git introuvable dans le PATH.\")\n            return False\n        self.append_log(f\">>> git {' '.join(args)}\")\n        self.btn_update.setEnabled(False)\n        worker = CommandWorker([git, *args], cwd=cwd)\n        self.worker = worker\n        worker.sig_line.connect(self.append_log)\n\n        def done(code: int):\n            self.append_log(f\">>> (exit={code})\")\n            self.worker = None\n            if next_cb:\n                next_cb(code)\n            else:\n                self.refresh_merge_state()\n\n        worker.sig_done.connect(done)\n        worker.start()\n        return True\n\n    def _run_git_sequence(self, commands: list[list[str]], cwd: pathlib.Path):\n        if not commands:\n            self.refresh_merge_state()\n            return\n\n        first, *rest = commands\n\n        def after(code: int):\n            if code == 0 and rest:\n                self._run_git_sequence(rest, cwd)\n            else:\n                self.refresh_merge_state()\n\n        if not self._launch_git(first, cwd, next_cb=after):\n            self.refresh_merge_state()\n\n    def on_git_merge_abort(self):\n        repo = self.find_git_root()\n        if not repo:\n            self.append_log(\"Pas de repo.\")\n            return\n        if not _is_merge_in_progress(repo):\n            QMessageBox.information(self, \"Git\", \"Aucun merge en cours.\")\n            return\n        self.append_log(f\">>> cwd: {repo}\")\n        self._launch_git([\"merge\", \"--abort\"], repo)\n\n    def on_git_continue_merge(self):\n        repo = self.find_git_root()\n        if not repo:\n            self.append_log(\"Pas de repo.\")\n            return\n        if not _is_merge_in_progress(repo):\n            QMessageBox.information(self, \"Git\", \"Aucun merge en cours.\")\n            return\n        self.append_log(f\">>> cwd: {repo}\")\n        if self._launch_git([\"status\"], repo):\n            self.append_log(\"Conseil: résous les conflits, puis `git add -A` et `git commit`.\\nUtilise 'Mettre à jour' ensuite.\")\n\n    def on_git_stash_pull(self):\n        repo = self.find_git_root()\n        if not repo:\n            self.append_log(\"Pas de repo.\")\n            return\n        self.append_log(f\">>> cwd: {repo}\")\n        cmds = [\n            [\"stash\", \"push\", \"-u\", \"-m\", \"flowgrab-auto\"],\n            [\"pull\", \"--rebase\", \"origin\", \"main\"],\n            [\"stash\", \"pop\"],\n        ]\n        self._run_git_sequence(cmds, repo)\n\n    # ---------- Actions ----------\n    def on_theme_change(self, _idx: int):\n        app = QApplication.instance()\n        if not app:\n            return\n        apply_dark_theme(app)\n        if self.cmb_theme.currentText() != \"Sombre\":\n            self.cmb_theme.blockSignals(True)\n            self.cmb_theme.setCurrentText(\"Sombre\")\n            self.cmb_theme.blockSignals(False)\n\n    def on_update_clicked(self):\n        import os, sys, subprocess, pathlib\n\n        repo_root = self.find_git_root()\n        if not repo_root:\n            QMessageBox.warning(self, \"Hors dépôt Git\", \"Aucun dossier '.git' trouvé en remontant depuis ce projet.\")\n            return\n\n        # Si un merge est en cours, on ne tente pas un pull auto\n        if _is_merge_in_progress(repo_root):\n            QMessageBox.information(self, \"Git\", \"Un merge est en cours. Résous-le avant de mettre à jour.\")\n            self.refresh_merge_state()\n            return\n\n        # Localise l’updater\n        updater_py = pathlib.Path(__file__).resolve().parent / \"scripts\" / \"updater.py\"\n        if not updater_py.exists():\n            QMessageBox.warning(self, \"Updater manquant\", f\"Fichier introuvable : {updater_py}\")\n            return\n\n        python_exe = sys.executable\n        main_script = os.path.abspath(sys.argv[0])\n\n        # Message utilisateur\n        QMessageBox.information(\n            self,\n            \"Mise à jour\",\n            \"L’application va se fermer, appliquer la mise à jour (git pull) puis redémarrer automatiquement.\"\n        )\n\n        try:\n            subprocess.Popen(\n                [python_exe, \"-u\", str(updater_py), str(repo_root), python_exe, main_script],\n                close_fds=True\n            )\n        except Exception as e:\n            QMessageBox.warning(self, \"Erreur\", f\"Impossible de lancer l’updater : {e}\")\n            return\n\n        # Ferme l'app courante pour libérer les fichiers avant le pull\n        app = QApplication.instance()\n        if app:\n            app.quit()\n\n    def on_update_done(self, code: int):\n        if code != 0:\n            QMessageBox.warning(\n                self,\n                \"Échec mise à jour\",\n                \"La commande git s'est terminée avec une erreur.\\nConsulte les logs.\",\n            )\n        else:\n            QMessageBox.information(\n                self,\n                \"Mise à jour OK\",\n                \"Pull terminé. Clique sur 'Redémarrer l’app' pour prendre en compte les changements.\",\n            )\n\n    def on_restart_clicked(self):\n        # Relance le même script avec les mêmes arguments\n        try:\n            subprocess.Popen([sys.executable, *sys.argv], close_fds=True)\n        except Exception as e:\n            QMessageBox.warning(self, \"Erreur\", f\"Impossible de redémarrer : {e}\")\n            return\n        QApplication.instance().quit()\n\n    # ---------- Utils ----------\n    def append_log(self, text: str):\n        self.logs.append(text)\n\n    def find_git_root(self) -> Optional[pathlib.Path]:\n        \"\"\"\n        Remonte depuis le dossier du script pour trouver un répertoire contenant '.git'.\n        \"\"\"\n        p = pathlib.Path(__file__).resolve().parent\n        for parent in [p, *p.parents]:\n            if (parent / \".git\").exists():\n                return parent\n        # dernier essai : si on exécute depuis un dossier qui a .git\n        if (pathlib.Path.cwd() / \".git\").exists():\n            return pathlib.Path.cwd()\n        return None\n\n# ---------------------- Fenêtre principale ----------------------\nclass Main(QWidget):\n    def __init__(self):\n        super().__init__()\n\n        def _is_elevated_win() -> bool:\n            if not sys.platform.startswith(\"win\"):\n                return False\n            try:\n                import ctypes\n\n                return bool(ctypes.windll.shell32.IsUserAnAdmin())  # type: ignore[attr-defined]\n            except Exception:\n                return False\n\n        if _is_elevated_win():\n            QMessageBox.information(\n                self,\n                \"Conseil\",\n                \"L’application tourne en mode administrateur. Si les cookies Chromium ne se déchiffrent pas (DPAPI), \"\n                \"relance l’app sans élévation ou force 'browser_cookies' = 'firefox' dans flowgrab_config.json.\",\n            )\n        self.setWindowTitle(\"FlowGrab — Video Downloader (yt-dlp)\")\n        root = QVBoxLayout(self)\n        # PATCH START: tabs wiring + config + signaux\n        self.app_config = load_config()\n        self.telegram_worker: TelegramWorker | None = None\n\n        self.youtube_tab = YoutubeTab(app_ref=QApplication.instance())\n        self.tiktok_tab = TikTokTab(app_ref=QApplication.instance())\n        self.transcription_tab = TranscriptionTab()\n        self.serveur_tab = ServeurTab()\n        self.settings_tab = SettingsTab(app_ref=self)\n\n        tabs = QTabWidget()\n        tabs.addTab(self.youtube_tab, \"YouTube\")\n        tabs.addTab(self.tiktok_tab, \"TikTok\")\n        tabs.addTab(self.transcription_tab, \"Transcription\")\n        tabs.addTab(ComingSoonTab(\"À venir 3\"), \"À venir 3\")\n        tabs.addTab(ComingSoonTab(\"À venir 4\"), \"À venir 4\")\n        tabs.addTab(self.settings_tab, \"Paramètres généraux\")\n        tabs.addTab(self.serveur_tab, \"Serveur\")\n        self.tabs = tabs\n        root.addWidget(tabs)\n\n        # Config JSON\n        self.transcription_tab.init_from_config(self.app_config)\n        self.settings_tab.init_from_config(self.app_config)\n\n        # Signaux inter-onglets\n        self.serveur_tab.sig_public_url.connect(self.on_cloudflare_public_url)       # base\n        self.youtube_tab.sig_request_transcription.connect(self.on_transcription_request)\n        self.youtube_tab.sig_audio_completed.connect(self.on_audio_ready_from_youtube)\n        self.tiktok_tab.sig_request_transcription.connect(self.on_transcription_request)\n        self.tiktok_tab.sig_audio_completed.connect(self.on_audio_ready_from_youtube)\n        self.transcription_tab.sig_url_changed.connect(self.on_transcription_url_changed)\n\n        # Paramètres Telegram\n        self.settings_tab.btn_tg_start.clicked.connect(self.start_telegram)\n        self.settings_tab.btn_tg_stop.clicked.connect(self.stop_telegram)\n        # PATCH END\n\n        start_notification_server(self)\n\n    # PATCH START: slots Main pour webhook et transcription\n    def on_cloudflare_public_url(self, base: str):\n        path = self.app_config.get(\"webhook_path\") or \"/webhook/Audio\"\n        if not path.startswith(\"/\"):\n            path = \"/\" + path\n        full = base.rstrip(\"/\") + path\n        self.app_config.update({\"webhook_base\": base, \"webhook_full\": full, \"webhook_path\": path})\n        save_config(self.app_config)\n        self.transcription_tab.set_webhook_full(full)\n\n    def on_transcription_request(self, file_paths: list[str]):\n        self.tabs.setCurrentWidget(self.transcription_tab)\n        self.transcription_tab.send_files_immediately(file_paths)\n\n    def on_transcription_url_changed(self, text: str):\n        path = getattr(self.transcription_tab, \"_webhook_path\", \"/webhook/Audio\") or \"/webhook/Audio\"\n        text = (text or \"\").strip()\n        if path and not path.startswith(\"/\"):\n            path = \"/\" + path\n        base = \"\"\n        if text and path and path in text:\n            idx = text.rfind(path)\n            if idx >= 0:\n                base = text[:idx]\n        if not base:\n            base = text.rstrip(\"/\")\n        self.app_config.update({\n            \"webhook_base\": base.rstrip(\"/\"),\n            \"webhook_full\": text,\n            \"webhook_path\": path,\n        })\n        save_config(self.app_config)\n    # PATCH END\n\n    # PATCH START: Telegram intégration\n    def _effective_telegram_mode(self) -> str:\n        return \"polling\"\n\n    def start_telegram(self):\n        token = (self.app_config.get(\"telegram_token\") or \"\").strip()\n        if not token:\n            QMessageBox.warning(self, \"Token manquant\", \"Renseigne le token du bot Telegram dans les paramètres.\")\n            return\n        if self.telegram_worker and self.telegram_worker.isRunning():\n            QMessageBox.information(self, \"Bot actif\", \"Le bot Telegram est déjà démarré.\")\n            return\n        worker = TelegramWorker(self.app_config)\n        self.telegram_worker = worker\n        worker.sig_download_requested.connect(self.on_tg_download_requested)\n        worker.sig_info.connect(self.on_telegram_info)\n        worker.finished.connect(self.on_telegram_finished)\n        mode = worker.effective_mode or self._effective_telegram_mode()\n        if self.settings_tab:\n            self.settings_tab.set_telegram_running(mode)\n            self.settings_tab.append_telegram_info(f\"Démarrage bot ({mode})\")\n        worker.start()\n\n    def stop_telegram(self):\n        if not self.telegram_worker:\n            if self.settings_tab:\n                self.settings_tab.set_telegram_idle()\n            return\n        worker = self.telegram_worker\n        if self.settings_tab:\n            self.settings_tab.append_telegram_info(\"Arrêt du bot demandé…\")\n        worker.stop()\n        worker.wait(5000)\n        self.telegram_worker = None\n        if self.settings_tab:\n            self.settings_tab.set_telegram_idle()\n\n    def on_telegram_finished(self):\n        if self.settings_tab:\n            self.settings_tab.set_telegram_idle()\n        if self.telegram_worker and not self.telegram_worker.isRunning():\n            self.telegram_worker = None\n\n    def on_telegram_info(self, text: str):\n        if self.settings_tab:\n            self.settings_tab.append_telegram_info(text)\n\n    def on_tg_download_requested(self, url: str, fmt: str, chat_id: int | str, title: str):\n        try:\n            chat_ref: int | str = int(chat_id)\n        except (TypeError, ValueError):\n            chat_ref = chat_id\n        item = self.youtube_tab.append_task(url)\n        task: Task = item.data(Qt.UserRole)\n        task.selected_fmt = fmt\n        task.source = \"telegram\"\n        task.chat_id = chat_ref\n        self.youtube_tab.statusBar(f\"Téléchargement demandé par Telegram — {title}\")\n        self.youtube_tab.start_queue()\n        if self.telegram_worker:\n            self.telegram_worker.send_message(chat_ref, \"Téléchargement lancé…\")\n\n    def on_audio_ready_from_youtube(self, chat_id: int | str, audio_path: str):\n        if not self.telegram_worker:\n            return\n        try:\n            chat_ref: int | str = int(chat_id)\n        except (TypeError, ValueError):\n            chat_ref = chat_id\n        name = os.path.basename(audio_path) or audio_path\n        self.telegram_worker.send_message(chat_ref, f\"Téléchargement terminé ✅\\n{name}\")\n        self.telegram_worker.ask_transcription(chat_ref, audio_path)\n    # PATCH END\n\n    def closeEvent(self, event):\n        try:\n            self.stop_telegram()\n        finally:\n            super().closeEvent(event)\n\n# ---------------------- main ----------------------\nif __name__ == \"__main__\":\n    app = QApplication(sys.argv)\n    apply_dark_theme(app)\n    w = Main()\n    w.show()\n    sys.exit(app.exec())\n",
  "requirements.txt": "python-telegram-bot>=21,<22\n",
  "scripts/updater.py": "import sys, subprocess, time, os, shutil, pathlib\n\n\ndef main():\n    if len(sys.argv) < 4:\n        print(\"Usage: updater.py <repo_root> <python_exe> <main_script>\")\n        return 2\n\n    repo_root   = pathlib.Path(sys.argv[1])\n    python_exe  = sys.argv[2]\n    main_script = os.path.abspath(sys.argv[3])\n\n    # Laisse le temps au process principal de se fermer et libérer les fichiers\n    time.sleep(1.2)\n\n    # Quelques tentatives pour s'assurer que le script principal n'est plus verrouillé\n    for _ in range(5):\n        try:\n            with open(main_script, \"rb\"):\n                pass\n            break\n        except Exception:\n            time.sleep(0.6)\n\n    git = shutil.which(\"git\")\n    ret = 0\n    if not git:\n        print(\"Git introuvable dans le PATH.\")\n        ret = 1\n    else:\n        print(f\"[Updater] git pull origin main — cwd={repo_root}\")\n        proc = subprocess.run([git, \"pull\", \"origin\", \"main\"], cwd=str(repo_root), text=True)\n        ret = proc.returncode or 0\n        print(f\"[Updater] git pull terminé (exit={ret})\")\n\n    # Relance l’application quoi qu’il arrive (même si la mise à jour échoue)\n    try:\n        subprocess.Popen([python_exe, main_script], close_fds=True)\n        print(\"[Updater] Application relancée.\")\n    except Exception as e:\n        print(f\"[Updater] Relance impossible : {e}\")\n        return 3\n\n    return ret\n\n\nif __name__ == \"__main__\":\n    raise SystemExit(main())\n"
}